<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="VEKTROID - Immersive vaporwave experience featuring Floral Shoppe aesthetics with interactive 3D visuals">
    <meta name="theme-color" content="#1a0a2e">
    <title>VEKTROID // フローラルの専門店</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=VT323&family=Orbitron:wght@400;700;900&family=Noto+Sans+JP:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --vapor-pink: #ff71ce;
            --vapor-cyan: #01cdfe;
            --vapor-purple: #b967ff;
            --vapor-blue: #05ffa1;
            --vapor-yellow: #fffb96;
            --vapor-dark: #1a0a2e;
            --vapor-darker: #0d0221;
        }

        * {
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            margin: 0;
            background: var(--vapor-darker);
            color: white;
            font-family: 'VT323', monospace;
            overflow-x: hidden;
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32" shape-rendering="crispEdges"><path d="M4 2 L4 22 L8 18 L10 26 L14 24 L12 16 L18 16 Z" fill="%23ffffff" stroke="%23000000" stroke-width="2"/><path d="M6 6 L6 18 L9 15 L11 22 L12 21 L10 14 L15 14 Z" fill="%23cfcfcf"/></svg>') 0 0, auto;
        }

        /* ============================================
           VAPORWAVE OVERLAY EFFECTS
           ============================================ */

        /* CRT Scanlines */
        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background:
                repeating-linear-gradient(0deg,
                    rgba(0, 0, 0, 0.15),
                    rgba(0, 0, 0, 0.15) 1px,
                    transparent 1px,
                    transparent 2px);
            pointer-events: none;
            z-index: 9998;
        }

        /* VHS Tracking Effect */
        .vhs-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9997;
            background: linear-gradient(180deg,
                    transparent 0%,
                    rgba(255, 113, 206, 0.03) 50%,
                    transparent 100%);
            animation: vhsScroll 8s linear infinite;
        }

        @keyframes vhsScroll {
            0% {
                transform: translateY(-100%);
            }

            100% {
                transform: translateY(100%);
            }
        }

        /* Chromatic Aberration */
        .chromatic-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9996;
            mix-blend-mode: screen;
            opacity: 0.3;
        }

        /* Vignette */
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9995;
            box-shadow: inset 0 0 150px rgba(0, 0, 0, 0.9);
        }

        /* ============================================
           ANIMATED STARS BACKGROUND
           ============================================ */
        .stars-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
        }

        @keyframes twinkle {

            0%,
            100% {
                opacity: 0.3;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        /* ============================================
           VAPORWAVE NAVBAR
           ============================================ */
        /* Windows XP Navbar */
        .xp-navbar {
            position: fixed;
            top: 0;
            width: 100%;
            height: 68px;
            background: linear-gradient(180deg, #245DDA 0%, #1F52C6 10%, #1941A5 100%);
            border-bottom: 2px solid #00368a;
            display: flex;
            align-items: center;
            padding: 0 5px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .start-btn {
            height: 100%;
            background: linear-gradient(180deg, #3EAE36 0%, #37952F 100%);
            border-radius: 0 15px 15px 0;
            padding: 0 15px 0 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            font-family: Tahoma, sans-serif;
            font-weight: bold;
            font-style: italic;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            box-shadow: inset 2px 2px 5px rgba(255, 255, 255, 0.3);
            margin-left: -5px;
            user-select: none;
        }

        .xp-nav-links {
            margin-left: 16px;
            font-family: Tahoma, sans-serif;
            font-size: 16px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .xp-nav-links a {
            color: rgba(255, 255, 255, 0.95);
            text-decoration: none;
        }

        .xp-nav-links a:hover {
            text-decoration: underline;
        }

        /* ============================================
           FLOATING DECORATIVE ELEMENTS
           ============================================ */
        .floating-element {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            opacity: 0.6;
            animation: floatAround 20s ease-in-out infinite;
        }

        .floating-palm {
            font-size: 4rem;
            filter: drop-shadow(0 0 20px var(--vapor-cyan));
        }

        .floating-statue {
            font-size: 3rem;
            filter: drop-shadow(0 0 15px var(--vapor-pink));
        }

        @keyframes floatAround {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
            }

            25% {
                transform: translateY(-20px) rotate(5deg);
            }

            50% {
                transform: translateY(0) rotate(0deg);
            }

            75% {
                transform: translateY(20px) rotate(-5deg);
            }
        }

        /* ============================================
           SECTIONS
           ============================================ */
        section {
            position: relative;
            width: 100%;
            min-height: 100vh;
            overflow: hidden;
        }

        /* ============================================
           HERO SECTION
           ============================================ */
        #hero {
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(180deg,
                    var(--vapor-darker) 0%,
                    #16082c 30%,
                    #2d1b4e 60%,
                    #1a0a2e 100%);
        }

        /* Foreground shadow to fade forward wireframes into black */
        .hero-front-shadow {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 40vh;
            z-index: 2;
            pointer-events: none;
            background: linear-gradient(180deg,
                    rgba(0, 0, 0, 0) 0%,
                    rgba(0, 0, 0, 0.35) 45%,
                    rgba(0, 0, 0, 0.85) 100%);
        }

        /* Retro Sun */
        .retro-sun-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            overflow: hidden;
        }

        .retro-sun {
            width: 500px;
            height: 500px;
            border-radius: 50%;
            background: linear-gradient(to top,
                    #ff00ff 0%,
                    #ff6b6b 30%,
                    #feca57 60%,
                    #ff9ff3 100%);
            position: relative;
            margin-top: -50px;
            box-shadow:
                0 0 60px #ff00ff,
                0 0 120px rgba(255, 107, 107, 0.5),
                0 0 200px rgba(254, 202, 87, 0.3);
            animation: sunPulse 4s ease-in-out infinite;

            /* Horizontal Lines */
            -webkit-mask-image: linear-gradient(to top,
                    transparent 0%, black 0%,
                    transparent 4%, black 4%,
                    transparent 8%, black 8%,
                    transparent 12%, black 12%,
                    transparent 17%, black 17%,
                    transparent 23%, black 23%,
                    transparent 30%, black 30%,
                    transparent 38%, black 38%,
                    transparent 48%, black 48%,
                    black 100%);
            mask-image: linear-gradient(to top,
                    transparent 0%, black 0%,
                    transparent 4%, black 4%,
                    transparent 8%, black 8%,
                    transparent 12%, black 12%,
                    transparent 17%, black 17%,
                    transparent 23%, black 23%,
                    transparent 30%, black 30%,
                    transparent 38%, black 38%,
                    transparent 48%, black 48%,
                    black 100%);
        }

        @keyframes sunPulse {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.1);
            }
        }

        #hero-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Hero Content */
        .hero-content {
            z-index: 10;
            text-align: center;
            pointer-events: none;
            position: absolute;
            top: 35%;
            width: 100%;
            padding: 0 20px;
        }

        /* Glitch Text Effect */
        .glitch-container {
            position: relative;
            display: inline-block;
        }

        .glitch-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 6rem;
            font-weight: 900;
            position: relative;
            text-transform: uppercase;
            letter-spacing: 10px;
            background: linear-gradient(to bottom, #00ffff, #ff00cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 4px 4px 0px rgba(255, 0, 204, 0.5);
            animation: pulse 2s infinite;
        }

        .glitch-text::before,
        .glitch-text::after {
            content: none;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.3);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .japanese-title {
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 2.5rem;
            color: var(--vapor-pink);
            margin-top: 10px;
            text-shadow:
                0 0 10px var(--vapor-pink),
                0 0 20px var(--vapor-pink),
                0 0 40px var(--vapor-pink);
            letter-spacing: 15px;
            animation: neonFlicker 2s infinite;
        }

        @keyframes neonFlicker {

            0%,
            19%,
            21%,
            23%,
            25%,
            54%,
            56%,
            100% {
                opacity: 1;
                text-shadow:
                    0 0 10px var(--vapor-pink),
                    0 0 20px var(--vapor-pink),
                    0 0 40px var(--vapor-pink);
            }

            20%,
            24%,
            55% {
                opacity: 0.8;
                text-shadow: none;
            }
        }

        .subtitle {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            color: var(--vapor-cyan);
            letter-spacing: 8px;
            margin-top: 20px;
            text-shadow: 0 0 10px var(--vapor-cyan);
        }

        .scroll-indicator {
            font-size: 1rem;
            color: var(--vapor-purple);
            margin-top: 50px;
            animation: bounce 2s infinite;
            opacity: 0.7;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        /* ============================================
           ALBUM SECTION
           ============================================ */
        #album-section {
            background: linear-gradient(180deg,
                    var(--vapor-dark) 0%,
                    #0f0520 50%,
                    var(--vapor-darker) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Top fade to match hero bottom fade */
        .album-top-shadow {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            height: 35vh;
            z-index: 15;
            pointer-events: none;
            background: linear-gradient(180deg,
                    rgba(0, 0, 0, 0.95) 0%,
                    rgba(0, 0, 0, 0.5) 40%,
                    rgba(0, 0, 0, 0) 100%);
        }

        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            background: linear-gradient(90deg, var(--vapor-pink), var(--vapor-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
            margin-top: 80px;
            letter-spacing: 5px;
        }

        .section-subtitle {
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--vapor-purple);
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        #album-canvas {
            width: 100%;
            height: 80vh;
            max-width: 900px;
            cursor: grab;
        }

        #album-canvas:active {
            cursor: grabbing;
        }

        /* Decorative Grid Floor */
        .grid-floor {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            background:
                linear-gradient(90deg,
                    rgba(255, 113, 206, 0.1) 1px,
                    transparent 1px),
                linear-gradient(rgba(1, 205, 254, 0.1) 1px,
                    transparent 1px);
            background-size: 50px 50px;
            transform: perspective(500px) rotateX(60deg);
            transform-origin: bottom;
            opacity: 0.5;
        }

        /* ============================================
           PLAYER SECTION
           ============================================ */
        #player-section {
            background: linear-gradient(180deg,
                    var(--vapor-darker) 0%,
                    #0a0015 50%,
                    #000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #player-canvas {
            width: 100%;
            height: 70vh;
            cursor: move;
        }

        .ui-overlay {
            position: absolute;
            bottom: 50px;
            display: flex;
            gap: 20px;
            z-index: 20;
        }

        .retro-btn {
            background: rgba(0, 0, 0, 0.8);
            color: var(--vapor-cyan);
            border: 2px solid var(--vapor-cyan);
            padding: 15px 30px;
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow:
                0 0 10px var(--vapor-cyan),
                inset 0 0 10px rgba(1, 205, 254, 0.2);
            transition: all 0.3s ease;
            letter-spacing: 2px;
        }

        .retro-btn:hover {
            background: var(--vapor-cyan);
            color: var(--vapor-darker);
            box-shadow:
                0 0 20px var(--vapor-cyan),
                0 0 40px var(--vapor-cyan);
        }

        #status-display {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--vapor-pink);
            padding: 15px 20px;
            color: var(--vapor-pink);
            font-family: 'VT323', monospace;
            font-size: 1.3rem;
            min-width: 200px;
            text-align: center;
            box-shadow: 0 0 10px rgba(255, 113, 206, 0.3);
        }

        /* ============================================
           FOOTER
           ============================================ */
        .vapor-footer {
            background: var(--vapor-darker);
            border-top: 1px solid var(--vapor-purple);
            padding: 40px 20px;
            text-align: center;
        }

        .footer-text {
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--vapor-purple);
            font-size: 1rem;
            opacity: 0.7;
        }

        .footer-jp {
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--vapor-pink);
            font-size: 1.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px var(--vapor-pink);
        }

        /* ============================================
           RESPONSIVE
           ============================================ */
        @media (max-width: 768px) {
            .glitch-text {
                font-size: 3rem;
                letter-spacing: 5px;
            }

            .japanese-title {
                font-size: 1.5rem;
                letter-spacing: 8px;
            }

            .subtitle {
                font-size: 1rem;
                letter-spacing: 4px;
            }

            .retro-sun {
                width: 300px;
                height: 300px;
            }

            .vapor-navbar {
                padding: 0 15px;
            }

            .nav-links {
                gap: 15px;
            }

            .nav-links a {
                font-size: 0.7rem;
            }

            .nav-jp {
                display: none;
            }

            .section-title {
                font-size: 1.8rem;
            }

            .ui-overlay {
                flex-direction: column;
                gap: 10px;
            }

            .floating-element {
                display: none;
            }
        }

        /* Reduced Motion */
        @media (prefers-reduced-motion: reduce) {

            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
            }

            html {
                scroll-behavior: auto;
            }
        }

        /* Focus states */
        a:focus,
        button:focus {
            outline: 2px solid var(--vapor-cyan);
            outline-offset: 3px;
        }
    </style>
</head>

<body>
    <!-- Overlay Effects -->
    <div class="crt-overlay"></div>
    <div class="vhs-overlay"></div>
    <div class="vignette"></div>

    <!-- Animated Stars -->
    <div class="stars-container" id="stars"></div>

    <!-- Navbar -->
    <nav class="xp-navbar" role="navigation" aria-label="Main navigation">
        <div class="start-btn" aria-label="Start">
            <div class="w-4 h-4 rounded-full bg-white relative overflow-hidden mr-2 border border-blue-800">
                <div class="absolute top-0 left-0 w-1/2 h-1/2 bg-[#F35325]"></div>
                <div class="absolute top-0 right-0 w-1/2 h-1/2 bg-[#81BC06]"></div>
                <div class="absolute bottom-0 left-0 w-1/2 h-1/2 bg-[#05A6F0]"></div>
                <div class="absolute bottom-0 right-0 w-1/2 h-1/2 bg-[#FFBA08]"></div>
            </div>
            <span>start</span>
        </div>
        <div class="xp-nav-links">
            <a href="#hero">System</a>
            <a href="#album-section">Artifacts</a>
            <a href="#player-section">Hardware</a>
        </div>
    </nav>

    <!-- Hero Section -->
    <section id="hero">
        <div class="retro-sun-container">
            <div class="retro-sun"></div>
        </div>
        <div id="hero-canvas"></div>
        <div class="hero-front-shadow" aria-hidden="true"></div>
        <div class="hero-content">
            <div class="glitch-container">
                <h1 class="glitch-text">VEKTROID</h1>
            </div>
            <p class="japanese-title">フローラルの専門店</p>
            <p class="subtitle">FLORAL SHOPPE // MACINTOSH PLUS</p>
            <p class="scroll-indicator">▼ スクロールして初期化 ▼</p>
        </div>
    </section>

    <!-- Album Section -->
    <section id="album-section">
        <div class="grid-floor"></div>
        <div class="album-top-shadow" aria-hidden="true"></div>
        <h2 class="section-title">ARTIFACT_アーカイブ</h2>
        <p class="section-subtitle">インタラクトして検査する</p>
        <div id="album-canvas"></div>
    </section>

    <!-- Player Section -->
    <section id="player-section">
        <div class="absolute top-24 text-center z-10 pointer-events-none px-4">
            <h2 class="section-title">HARDWARE_ハードウェア</h2>
            <p class="section-subtitle">ドラッグして回転 // ボタンをクリックして操作</p>
        </div>
        <div id="player-canvas"></div>
        <div class="ui-overlay">
            <button class="retro-btn" id="insert-tape-btn">テープを挿入</button>
            <div id="status-display">NO TAPE テープなし</div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="vapor-footer">
        <p class="footer-jp">私はあなたに会いたいです</p>
        <p class="footer-text">© 2024 VEKTROID // ALL RIGHTS RESERVED // 全著作権所有</p>
    </footer>

    <script>
        /* ============================================
           GENERATE ANIMATED STARS
           ============================================ */
        (function () {
            const starsContainer = document.getElementById('stars');
            const numStars = 150;

            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = Math.random() * 3 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.animationDelay = Math.random() * 3 + 's';
                star.style.animationDuration = (Math.random() * 2 + 2) + 's';
                starsContainer.appendChild(star);
            }
        })();

        /* ============================================
           SCENE 1: HERO - VAPORWAVE GRID TERRAIN
           ============================================ */
        (function () {
            const container = document.getElementById('hero-canvas');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x1a0a2e, 0.015);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2.6, 7.5);
            camera.lookAt(0, 0.2, -18);

            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // Grid Terrain
            const tileDepth = 50;
            const tileWidth = 120;
            const segmentsW = 48;
            const segmentsD = 20;

            const geometry = new THREE.PlaneGeometry(tileWidth, tileDepth, segmentsW, segmentsD);
            const pos = geometry.attributes.position;

            // Use coefficient that ensures seamless tiling (2π/tileDepth for perfect periodicity)
            const yCoef = (2 * Math.PI) / tileDepth;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);

                let z = 0;
                z += Math.sin(x * 0.08) * 1.5;
                z += Math.cos(x * 0.2 + y * yCoef) * 1;

                const dist = Math.abs(x) / (tileWidth / 2);
                z += Math.pow(dist, 2.5) * 8;

                pos.setZ(i, z);
            }
            geometry.computeVertexNormals();

            // Gradient wireframe material
            const tiles = [];
            const tileMats = [];
            for (let i = 0; i < 4; i++) {
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff71ce,
                    wireframe: true,
                    transparent: true,
                    opacity: 0
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(0, -5, -i * tileDepth);
                scene.add(mesh);
                tiles.push(mesh);
                tileMats.push(material);
            }

            // Add vertical grid lines (columns effect)
            const columnGeometry = new THREE.BoxGeometry(0.1, 15, 0.1);
            const columnMaterial = new THREE.MeshBasicMaterial({
                color: 0x01cdfe,
                transparent: true,
                opacity: 0.3
            });

            for (let i = -5; i <= 5; i++) {
                const column = new THREE.Mesh(columnGeometry, columnMaterial);
                column.position.set(i * 8, 2, -30);
                scene.add(column);
            }

            let time = 0;

            function smoothstep(edge0, edge1, x) {
                const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
                return t * t * (3 - 2 * t);
            }

            function animate() {
                requestAnimationFrame(animate);
                time += 0.01;

                const speed = 0.12;
                tiles.forEach(tile => {
                    tile.position.z += speed;
                    if (tile.position.z >= tileDepth) {
                        tile.position.z -= tileDepth * 4;
                    }
                });

                // Color cycling
                const hue = (Math.sin(time * 0.5) + 1) / 2;
                tileMats.forEach((mat, idx) => {
                    mat.color.setHSL(hue * 0.1 + 0.85, 1, 0.6);

                    // Distance-based fade: far tiles spawn fully transparent
                    const z = tiles[idx].position.z;
                    const farZ = -tileDepth * 3.0;   // most distant tile start
                    const nearZ = tileDepth * 0.35;  // closer region becomes opaque
                    const opacity = smoothstep(farZ, nearZ, z);
                    mat.opacity = opacity;
                });

                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        })();

        /* ============================================
           SCENE 2: ALBUM - FLOATING BUST & GLASS
           ============================================ */
        (function () {
            const container = document.getElementById('album-canvas');
            const width = container.clientWidth;
            const height = container.clientHeight;

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 100);
            camera.position.z = 7;

            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(width, height);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            // Vaporwave Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);

            const pinkLight = new THREE.PointLight(0xff71ce, 3, 20);
            pinkLight.position.set(5, 5, 5);
            scene.add(pinkLight);

            const cyanLight = new THREE.PointLight(0x01cdfe, 3, 20);
            cyanLight.position.set(-5, -3, 5);
            scene.add(cyanLight);

            const purpleLight = new THREE.PointLight(0xb967ff, 2, 15);
            purpleLight.position.set(0, 5, -5);
            scene.add(purpleLight);

            // Vaporwave Art Generator
            function generateVaporwaveArt() {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');

                // Gradient background
                const gradient = ctx.createLinearGradient(0, 0, 512, 512);
                gradient.addColorStop(0, '#ff71ce');
                gradient.addColorStop(0.5, '#b967ff');
                gradient.addColorStop(1, '#01cdfe');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);

                // Grid lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 512; i += 30) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(512, i);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, 512);
                    ctx.stroke();
                }

                // Japanese text
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 40px "Noto Sans JP", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('フローラル', 256, 200);
                ctx.fillText('専門店', 256, 260);

                // English text
                ctx.font = 'bold 30px Orbitron, sans-serif';
                ctx.fillText('VEKTROID', 256, 350);

                return new THREE.CanvasTexture(canvas);
            }

            const pivot = new THREE.Group();
            scene.add(pivot);

            // Album Art
            const albumGeo = new THREE.BoxGeometry(2.5, 2.5, 0.15);
            const albumMat = new THREE.MeshStandardMaterial({
                map: generateVaporwaveArt(),
                emissive: 0x333333,
                roughness: 0.3,
                metalness: 0.1
            });
            const album = new THREE.Mesh(albumGeo, albumMat);
            pivot.add(album);

            // Glass Cube
            const glassGeo = new THREE.BoxGeometry(3, 3, 3);
            const glassMat = new THREE.MeshPhysicalMaterial({
                roughness: 0.05,
                metalness: 0,
                transmission: 0.9,
                thickness: 0.5,
                ior: 1.5,
                clearcoat: 1,
                clearcoatRoughness: 0.1,
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            });
            const glass = new THREE.Mesh(glassGeo, glassMat);
            pivot.add(glass);

            // Add floating particles
            const particleGeo = new THREE.BufferGeometry();
            const particleCount = 100;
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 10;
                positions[i + 1] = (Math.random() - 0.5) * 10;
                positions[i + 2] = (Math.random() - 0.5) * 10;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMat = new THREE.PointsMaterial({
                color: 0xff71ce,
                size: 0.05,
                transparent: true,
                opacity: 0.6
            });
            const particles = new THREE.Points(particleGeo, particleMat);
            scene.add(particles);

            // Interaction
            let isDragging = false;
            let pointerId = null;
            let previousPointer = { x: 0, y: 0 };
            let rotVel = { x: 0, y: 0 };
            const dragSensitivity = 0.008;
            const damping = 0.92;

            container.style.touchAction = 'none';

            container.addEventListener('pointerdown', (e) => {
                isDragging = true;
                pointerId = e.pointerId;
                container.setPointerCapture(pointerId);
                previousPointer = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('pointerup', () => {
                isDragging = false;
                pointerId = null;
            });

            container.addEventListener('pointercancel', () => {
                isDragging = false;
                pointerId = null;
            });

            container.addEventListener('pointermove', (e) => {
                if (!isDragging || e.pointerId !== pointerId) return;
                const deltaX = e.clientX - previousPointer.x;
                const deltaY = e.clientY - previousPointer.y;
                const vx = deltaY * dragSensitivity;
                const vy = deltaX * dragSensitivity;

                pivot.rotation.x += vx;
                pivot.rotation.y += vy;

                rotVel.x = vx;
                rotVel.y = vy;
                previousPointer = { x: e.clientX, y: e.clientY };
            });

            function lerp(a, b, t) {
                return a + (b - a) * t;
            }

            function animate() {
                requestAnimationFrame(animate);
                const t = Date.now() * 0.001;

                if (!isDragging) {
                    // Inertia
                    pivot.rotation.x += rotVel.x;
                    pivot.rotation.y += rotVel.y;
                    rotVel.x *= damping;
                    rotVel.y *= damping;

                    // Subtle idle motion when inertia is low
                    const inertiaMag = Math.abs(rotVel.x) + Math.abs(rotVel.y);
                    if (inertiaMag < 0.0008) {
                        const targetX = Math.sin(t * 0.3) * 0.1;
                        pivot.rotation.y += 0.003;
                        pivot.rotation.x = lerp(pivot.rotation.x, targetX, 0.03);
                    }
                }

                // Animate particles
                particles.rotation.y += 0.001;
                particles.rotation.x += 0.0005;

                // Animate lights
                pinkLight.position.x = Math.sin(t) * 5;
                cyanLight.position.y = Math.cos(t * 0.7) * 5;

                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            });
        })();

        /* ============================================
           SCENE 3: VAPORWAVE CASSETTE PLAYER
           ============================================ */
        (function () {
            const container = document.getElementById('player-canvas');
            let width = container.clientWidth;
            let height = container.clientHeight;

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0015);

            const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
            camera.position.set(8, 5, 8);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Vaporwave Lighting
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const pinkLight = new THREE.PointLight(0xff71ce, 2, 20);
            pinkLight.position.set(-5, 3, 5);
            scene.add(pinkLight);

            const cyanLight = new THREE.PointLight(0x01cdfe, 2, 20);
            cyanLight.position.set(5, 3, -5);
            scene.add(cyanLight);

            const ambLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambLight);

            // Grid Floor
            const gridHelper = new THREE.GridHelper(20, 20, 0xff71ce, 0x01cdfe);
            gridHelper.position.y = -3;
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            const playerGroup = new THREE.Group();
            scene.add(playerGroup);

            // Materials with vaporwave colors
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                roughness: 0.3,
                metalness: 0.5
            });
            const accentMat = new THREE.MeshStandardMaterial({
                color: 0xff71ce,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0xff71ce,
                emissiveIntensity: 0.2
            });
            const windowMat = new THREE.MeshPhysicalMaterial({
                color: 0x111111,
                transmission: 0.8,
                thickness: 1,
                roughness: 0.1
            });
            const innerDarkMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const chassisGroup = new THREE.Group();
            playerGroup.add(chassisGroup);

            // Back Plate
            const back = new THREE.Mesh(new THREE.BoxGeometry(4.5, 5.5, 0.5), bodyMat);
            back.position.z = -0.8;
            back.castShadow = true;
            chassisGroup.add(back);

            // Accent strips
            const stripGeo = new THREE.BoxGeometry(4.6, 0.1, 0.6);
            const topStrip = new THREE.Mesh(stripGeo, accentMat);
            topStrip.position.set(0, 2.5, 0);
            chassisGroup.add(topStrip);

            const bottomStrip = new THREE.Mesh(stripGeo, accentMat);
            bottomStrip.position.set(0, -2.5, 0);
            chassisGroup.add(bottomStrip);

            // Dark inner void
            const voidBox = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2.8, 0.1), innerDarkMat);
            voidBox.position.set(0, 0.25, -0.54);
            chassisGroup.add(voidBox);

            // Bottom Block
            const bottom = new THREE.Mesh(new THREE.BoxGeometry(4.5, 1.5, 1.5), bodyMat);
            bottom.position.set(0, -1.75, 0);
            bottom.castShadow = true;
            chassisGroup.add(bottom);

            // Top Block
            const top = new THREE.Mesh(new THREE.BoxGeometry(4.5, 1, 1.5), bodyMat);
            top.position.set(0, 2, 0);
            top.castShadow = true;
            chassisGroup.add(top);

            // Sides
            const left = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.75, 1.5), bodyMat);
            left.position.set(-1.95, 0.125, 0);
            chassisGroup.add(left);

            const right = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.75, 1.5), bodyMat);
            right.position.set(1.95, 0.125, 0);
            chassisGroup.add(right);

            // Door Frame
            const doorGroup = new THREE.Group();
            doorGroup.position.set(0, 0.25, 0.75);
            playerGroup.add(doorGroup);

            const glassPanel = new THREE.Mesh(new THREE.BoxGeometry(3.0, 2.0, 0.05), windowMat);
            doorGroup.add(glassPanel);

            // Vaporwave Buttons
            const buttons = [];
            const btnColors = [0xff71ce, 0x01cdfe, 0xb967ff, 0x05ffa1];

            function createBtn(x, colorIndex, name) {
                const geo = new THREE.BoxGeometry(0.8, 0.3, 0.4);
                const mat = new THREE.MeshStandardMaterial({
                    color: btnColors[colorIndex],
                    emissive: btnColors[colorIndex],
                    emissiveIntensity: 0.3,
                    roughness: 0.2,
                    metalness: 0.8
                });
                const btn = new THREE.Mesh(geo, mat);
                btn.position.set(x, 2.65, 0);
                btn.castShadow = true;
                btn.userData = { isButton: true, name: name, originalY: 2.65 };
                playerGroup.add(btn);
                buttons.push(btn);
            }

            createBtn(-1.5, 0, 'stop');
            createBtn(-0.5, 1, 'rewind');
            createBtn(0.5, 2, 'play');
            createBtn(1.5, 3, 'ff');

            // Cassette Tape with vaporwave styling
            const tapeGroup = new THREE.Group();
            const tapeBody = new THREE.Mesh(
                new THREE.BoxGeometry(3, 1.8, 0.3),
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 })
            );

            // Gradient label
            const labelCanvas = document.createElement('canvas');
            labelCanvas.width = 256;
            labelCanvas.height = 64;
            const labelCtx = labelCanvas.getContext('2d');
            const labelGradient = labelCtx.createLinearGradient(0, 0, 256, 0);
            labelGradient.addColorStop(0, '#ff71ce');
            labelGradient.addColorStop(0.5, '#b967ff');
            labelGradient.addColorStop(1, '#01cdfe');
            labelCtx.fillStyle = labelGradient;
            labelCtx.fillRect(0, 0, 256, 64);
            labelCtx.fillStyle = 'white';
            labelCtx.font = 'bold 20px sans-serif';
            labelCtx.textAlign = 'center';
            labelCtx.fillText('FLORAL SHOPPE', 128, 40);

            const labelTexture = new THREE.CanvasTexture(labelCanvas);
            const tapeLabel = new THREE.Mesh(
                new THREE.BoxGeometry(2.8, 0.5, 0.32),
                new THREE.MeshBasicMaterial({ map: labelTexture })
            );
            tapeLabel.position.y = 0.5;
            tapeGroup.add(tapeBody);
            tapeGroup.add(tapeLabel);

            // Tape Reels
            const reelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.35, 16);
            const reelMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.3,
                metalness: 0.7
            });
            const leftReel = new THREE.Mesh(reelGeo, reelMat);
            const rightReel = new THREE.Mesh(reelGeo, reelMat);
            leftReel.rotation.x = Math.PI / 2;
            rightReel.rotation.x = Math.PI / 2;
            leftReel.position.set(-0.8, -0.2, 0.1);
            rightReel.position.set(0.8, -0.2, 0.1);

            const tooth = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.4, 0.1),
                new THREE.MeshBasicMaterial({ color: 0x000 })
            );
            leftReel.add(tooth);
            rightReel.add(tooth.clone());
            tapeGroup.add(leftReel);
            tapeGroup.add(rightReel);

            // Keep the tape in playerGroup local space so it always matches rotation
            tapeGroup.position.set(6, 0.25, 0);
            playerGroup.add(tapeGroup);

            // Interaction
            let isDragging = false;
            let pointerId = null;
            let previousPointer = { x: 0, y: 0 };
            let rotVel = { x: 0, y: 0 };
            const dragSensitivity = 0.01;
            const damping = 0.9;
            let tapeInserted = false;
            let isPlaying = false;

            container.style.touchAction = 'none';

            container.addEventListener('pointerdown', (e) => {
                isDragging = true;
                pointerId = e.pointerId;
                container.setPointerCapture(pointerId);
                previousPointer = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('pointerup', () => {
                isDragging = false;
                pointerId = null;
            });

            container.addEventListener('pointercancel', () => {
                isDragging = false;
                pointerId = null;
            });

            container.addEventListener('pointermove', (e) => {
                if (!isDragging || e.pointerId !== pointerId) return;
                const deltaX = e.clientX - previousPointer.x;
                const deltaY = e.clientY - previousPointer.y;

                const vy = deltaX * dragSensitivity;
                const vx = deltaY * dragSensitivity;

                playerGroup.rotation.y += vy;
                playerGroup.rotation.x += vx;

                // Clamp X rotation a bit so it doesn't flip
                playerGroup.rotation.x = Math.max(-0.9, Math.min(0.6, playerGroup.rotation.x));

                rotVel.x = vx;
                rotVel.y = vy;
                previousPointer = { x: e.clientX, y: e.clientY };
            });

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            container.addEventListener('click', (event) => {
                const rect = container.getBoundingClientRect();
                const currentWidth = rect.width;
                const currentHeight = rect.height;
                mouse.x = ((event.clientX - rect.left) / currentWidth) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / currentHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(playerGroup.children);
                for (let i = 0; i < intersects.length; i++) {
                    if (intersects[i].object.userData.isButton) pressButton(intersects[i].object);
                }
            });

            function pressButton(btn) {
                const targetY = btn.userData.originalY - 0.2;
                buttons.forEach(b => b.position.y = b.userData.originalY);
                btn.position.y = targetY;
                const status = document.getElementById('status-display');

                if (!tapeInserted) {
                    status.innerText = 'NO TAPE テープなし';
                    status.style.color = '#ff71ce';
                    return;
                }

                if (btn.userData.name === 'play') {
                    status.innerText = '再生中 PLAYING >>';
                    status.style.color = '#05ffa1';
                    isPlaying = true;
                } else if (btn.userData.name === 'stop') {
                    status.innerText = '停止 STOPPED';
                    status.style.color = '#ff71ce';
                    isPlaying = false;
                } else if (btn.userData.name === 'rewind') {
                    status.innerText = '巻き戻し <<';
                    status.style.color = '#01cdfe';
                } else {
                    status.innerText = '早送り >>';
                    status.style.color = '#b967ff';
                }
            }

            document.getElementById('insert-tape-btn').addEventListener('click', () => {
                if (tapeInserted) return;

                let pos = tapeGroup.position.x;
                const insertAnim = setInterval(() => {
                    pos -= 0.15;
                    tapeGroup.position.x = pos;

                    if (pos <= 0) {
                        clearInterval(insertAnim);
                        tapeGroup.position.set(0, 0.25, 0);
                        tapeInserted = true;
                        document.getElementById('status-display').innerText = 'ロード完了 LOADED';
                        document.getElementById('status-display').style.color = '#01cdfe';
                    }
                }, 16);
            });

            function animate() {
                requestAnimationFrame(animate);
                const t = Date.now() * 0.001;

                if (!isDragging) {
                    // Inertia
                    playerGroup.rotation.x += rotVel.x;
                    playerGroup.rotation.y += rotVel.y;
                    playerGroup.rotation.x = Math.max(-0.9, Math.min(0.6, playerGroup.rotation.x));
                    rotVel.x *= damping;
                    rotVel.y *= damping;
                }

                renderer.render(scene, camera);

                if (tapeInserted && isPlaying) {
                    leftReel.rotation.y -= 0.1;
                    rightReel.rotation.y -= 0.1;
                }

                // Animate lights
                pinkLight.position.x = Math.sin(t * 0.5) * 5;
                cyanLight.position.z = Math.cos(t * 0.5) * 5;

                // Subtle grid animation
                gridHelper.rotation.y += 0.001;
            }
            animate();

            window.addEventListener('resize', () => {
                width = container.clientWidth;
                height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
        })();
    </script>
</body>

</html>