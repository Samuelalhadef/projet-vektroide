<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="VEKTROID - Immersive vaporwave experience featuring Floral Shoppe aesthetics with interactive 3D visuals">
    <meta name="theme-color" content="#1a0a2e">
    <title>VEKTROID // フローラルの専門店</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=VT323&family=Orbitron:wght@400;700;900&family=Noto+Sans+JP:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --vapor-pink: #ff71ce;
            --vapor-cyan: #01cdfe;
            --vapor-purple: #b967ff;
            --vapor-blue: #05ffa1;
            --vapor-yellow: #fffb96;
            --vapor-dark: #1a0a2e;
            --vapor-darker: #0d0221;
        }

        * {
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            margin: 0;
            background: var(--vapor-darker);
            color: white;
            font-family: 'VT323', monospace;
            overflow-x: hidden;
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32" shape-rendering="crispEdges"><path d="M4 2 L4 22 L8 18 L10 26 L14 24 L12 16 L18 16 Z" fill="%23ffffff" stroke="%23000000" stroke-width="2"/><path d="M6 6 L6 18 L9 15 L11 22 L12 21 L10 14 L15 14 Z" fill="%23cfcfcf"/></svg>') 0 0, auto;
        }

        /* ============================================
           VAPORWAVE OVERLAY EFFECTS
           ============================================ */

        /* CRT Scanlines */
        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background:
                repeating-linear-gradient(0deg,
                    rgba(0, 0, 0, 0.15),
                    rgba(0, 0, 0, 0.15) 1px,
                    transparent 1px,
                    transparent 2px);
            pointer-events: none;
            z-index: 9998;
        }

        /* VHS Tracking Effect */
        .vhs-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9997;
            background: linear-gradient(180deg,
                    transparent 0%,
                    rgba(255, 113, 206, 0.03) 50%,
                    transparent 100%);
            animation: vhsScroll 8s linear infinite;
        }

        @keyframes vhsScroll {
            0% {
                transform: translateY(-100%);
            }

            100% {
                transform: translateY(100%);
            }
        }

        /* Chromatic Aberration */
        .chromatic-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9996;
            mix-blend-mode: screen;
            opacity: 0.3;
        }

        /* Vignette */
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9995;
            box-shadow: inset 0 0 150px rgba(0, 0, 0, 0.9);
        }

        /* ============================================
           ANIMATED STARS BACKGROUND
           ============================================ */
        .stars-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
        }

        @keyframes twinkle {

            0%,
            100% {
                opacity: 0.3;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        /* ============================================
           VAPORWAVE NAVBAR
           ============================================ */
        /* Windows XP Navbar */
        .xp-navbar {
            position: fixed;
            top: 0;
            width: 100%;
            height: 68px;
            background: linear-gradient(180deg, #245DDA 0%, #1F52C6 10%, #1941A5 100%);
            border-bottom: 2px solid #00368a;
            display: flex;
            align-items: center;
            padding: 0 5px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .start-btn {
            height: 100%;
            background: linear-gradient(180deg, #3EAE36 0%, #37952F 100%);
            border-radius: 0 15px 15px 0;
            padding: 0 15px 0 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            font-family: Tahoma, sans-serif;
            font-weight: bold;
            font-style: italic;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            box-shadow: inset 2px 2px 5px rgba(255, 255, 255, 0.3);
            margin-left: -5px;
            user-select: none;
        }

        .xp-nav-links {
            margin-left: 16px;
            font-family: Tahoma, sans-serif;
            font-size: 16px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .xp-nav-links a {
            color: rgba(255, 255, 255, 0.95);
            text-decoration: none;
        }

        .xp-nav-links a:hover {
            text-decoration: underline;
        }

        /* ============================================
           FLOATING DECORATIVE ELEMENTS
           ============================================ */
        .floating-element {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            opacity: 0.6;
            animation: floatAround 20s ease-in-out infinite;
        }

        .floating-palm {
            font-size: 4rem;
            filter: drop-shadow(0 0 20px var(--vapor-cyan));
        }

        .floating-statue {
            font-size: 3rem;
            filter: drop-shadow(0 0 15px var(--vapor-pink));
        }

        @keyframes floatAround {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
            }

            25% {
                transform: translateY(-20px) rotate(5deg);
            }

            50% {
                transform: translateY(0) rotate(0deg);
            }

            75% {
                transform: translateY(20px) rotate(-5deg);
            }
        }

        /* ============================================
           SECTIONS
           ============================================ */
        section {
            position: relative;
            width: 100%;
            min-height: 100vh;
            overflow: hidden;
        }

        /* ============================================
           HERO SECTION
           ============================================ */
        #hero {
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(180deg,
                    var(--vapor-darker) 0%,
                    #16082c 30%,
                    #2d1b4e 60%,
                    #1a0a2e 100%);
        }

        /* Foreground shadow to fade forward wireframes into black */
        .hero-front-shadow {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 40vh;
            z-index: 2;
            pointer-events: none;
            background: linear-gradient(180deg,
                    rgba(0, 0, 0, 0) 0%,
                    rgba(0, 0, 0, 0.35) 45%,
                    rgba(0, 0, 0, 0.85) 100%);
        }

        /* Retro Sun */
        .retro-sun-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            overflow: hidden;
        }

        .retro-sun {
            width: 500px;
            height: 500px;
            border-radius: 50%;
            background: linear-gradient(to top,
                    #ff00ff 0%,
                    #ff6b6b 30%,
                    #feca57 60%,
                    #ff9ff3 100%);
            position: relative;
            margin-top: -50px;
            box-shadow:
                0 0 60px #ff00ff,
                0 0 120px rgba(255, 107, 107, 0.5),
                0 0 200px rgba(254, 202, 87, 0.3);
            animation: sunPulse 4s ease-in-out infinite;

            /* Horizontal Lines */
            -webkit-mask-image: linear-gradient(to top,
                    transparent 0%, black 0%,
                    transparent 4%, black 4%,
                    transparent 8%, black 8%,
                    transparent 12%, black 12%,
                    transparent 17%, black 17%,
                    transparent 23%, black 23%,
                    transparent 30%, black 30%,
                    transparent 38%, black 38%,
                    transparent 48%, black 48%,
                    black 100%);
            mask-image: linear-gradient(to top,
                    transparent 0%, black 0%,
                    transparent 4%, black 4%,
                    transparent 8%, black 8%,
                    transparent 12%, black 12%,
                    transparent 17%, black 17%,
                    transparent 23%, black 23%,
                    transparent 30%, black 30%,
                    transparent 38%, black 38%,
                    transparent 48%, black 48%,
                    black 100%);
        }

        @keyframes sunPulse {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.1);
            }
        }

        #hero-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Hero masked layer (hero model + pillars) */
        #hero-model-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #hero-model-reveal {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* hidden by default */
            clip-path: inset(100% 0px 0px 0px);
            filter: drop-shadow(0 0 24px rgba(1, 205, 254, 0.14)) drop-shadow(0 0 28px rgba(255, 113, 206, 0.12));
        }

        #hero-model-reveal::after {
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            top: -50%;
            bottom: -50%;
            opacity: 0;
            background:
                repeating-linear-gradient(0deg,
                    rgba(255, 255, 255, 0.07),
                    rgba(255, 255, 255, 0.07) 1px,
                    transparent 1px,
                    transparent 5px);
            mix-blend-mode: screen;
            transform: translateY(0);
        }

        #hero-model-reveal.is-revealing::after {
            opacity: 0.5;
            animation: heroModelScan 900ms linear infinite;
        }

        @keyframes heroModelScan {
            0% {
                transform: translateY(-15%);
            }

            100% {
                transform: translateY(15%);
            }
        }

        #hero-model-reveal canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Hero Content */
        .hero-content {
            z-index: 10;
            text-align: center;
            pointer-events: none;
            position: absolute;
            top: 35%;
            width: 100%;
            padding: 0 20px;
        }

        /* Glitch Text Effect */
        .glitch-container {
            position: relative;
            display: inline-block;
        }

        .glitch-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 6rem;
            font-weight: 900;
            position: relative;
            text-transform: uppercase;
            letter-spacing: 10px;
            background: linear-gradient(to bottom, #00ffff, #ff00cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 4px 4px 0px rgba(255, 0, 204, 0.5);
            animation: pulse 2s infinite;
        }

        .glitch-text::before,
        .glitch-text::after {
            content: none;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.3);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .japanese-title {
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 2.5rem;
            color: var(--vapor-pink);
            margin-top: 10px;
            text-shadow:
                0 0 10px var(--vapor-pink),
                0 0 20px var(--vapor-pink),
                0 0 40px var(--vapor-pink);
            letter-spacing: 15px;
            animation: neonFlicker 2s infinite;
        }

        @keyframes neonFlicker {

            0%,
            19%,
            21%,
            23%,
            25%,
            54%,
            56%,
            100% {
                opacity: 1;
                text-shadow:
                    0 0 10px var(--vapor-pink),
                    0 0 20px var(--vapor-pink),
                    0 0 40px var(--vapor-pink);
            }

            20%,
            24%,
            55% {
                opacity: 0.8;
                text-shadow: none;
            }
        }

        .subtitle {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            color: var(--vapor-cyan);
            letter-spacing: 8px;
            margin-top: 20px;
            text-shadow: 0 0 10px var(--vapor-cyan);
        }

        .scroll-indicator {
            font-size: 1rem;
            color: var(--vapor-purple);
            margin-top: 50px;
            animation: bounce 2s infinite;
            opacity: 0.7;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        /* ============================================
           ALBUM SECTION
           ============================================ */
        #album-section {
            background: linear-gradient(180deg,
                    var(--vapor-dark) 0%,
                    #0f0520 50%,
                    var(--vapor-darker) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Top fade to match hero bottom fade */
        .album-top-shadow {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            height: 35vh;
            z-index: 15;
            pointer-events: none;
            background: linear-gradient(180deg,
                    rgba(0, 0, 0, 0.95) 0%,
                    rgba(0, 0, 0, 0.5) 40%,
                    rgba(0, 0, 0, 0) 100%);
        }

        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            background: linear-gradient(90deg, var(--vapor-pink), var(--vapor-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
            margin-top: 80px;
            letter-spacing: 5px;
        }

        .section-subtitle {
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--vapor-purple);
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        #album-canvas {
            width: 100%;
            height: 80vh;
            max-width: 900px;
            cursor: grab;
        }

        #album-canvas:active {
            cursor: grabbing;
        }

        /* Decorative Grid Floor */
        .grid-floor {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            background:
                linear-gradient(90deg,
                    rgba(255, 113, 206, 0.1) 1px,
                    transparent 1px),
                linear-gradient(rgba(1, 205, 254, 0.1) 1px,
                    transparent 1px);
            background-size: 50px 50px;
            transform: perspective(500px) rotateX(60deg);
            transform-origin: bottom;
            opacity: 0.5;
        }

        /* ============================================
           PLAYER SECTION
           ============================================ */
        #player-section {
            background: linear-gradient(180deg,
                    var(--vapor-darker) 0%,
                    #0a0015 50%,
                    #000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #player-canvas {
            width: 100%;
            height: 70vh;
            cursor: move;
            position: relative;
            z-index: 3;
        }

        .ui-overlay {
            position: absolute;
            bottom: 50px;
            display: flex;
            gap: 20px;
            z-index: 20;
        }

        .retro-btn {
            background: rgba(0, 0, 0, 0.8);
            color: var(--vapor-cyan);
            border: 2px solid var(--vapor-cyan);
            padding: 15px 30px;
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow:
                0 0 10px var(--vapor-cyan),
                inset 0 0 10px rgba(1, 205, 254, 0.2);
            transition: all 0.3s ease;
            letter-spacing: 2px;
        }

        .retro-btn:hover {
            background: var(--vapor-cyan);
            color: var(--vapor-darker);
            box-shadow:
                0 0 20px var(--vapor-cyan),
                0 0 40px var(--vapor-cyan);
        }

        #status-display {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--vapor-pink);
            padding: 15px 20px;
            color: var(--vapor-pink);
            font-family: 'VT323', monospace;
            font-size: 1.3rem;
            min-width: 200px;
            text-align: center;
            box-shadow: 0 0 10px rgba(255, 113, 206, 0.3);
        }

        /* Audio Visualizer */
        #audio-visualizer {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            /* Visible by default as a background layer (like the hero sun) */
            opacity: 0.35;
            transition: opacity 220ms ease;
            mix-blend-mode: screen;
            filter: blur(0.2px) saturate(1.25);
        }

        #audio-visualizer.is-active {
            opacity: 0.85;
        }

        /* ============================================
           FOOTER
           ============================================ */
        .vapor-footer {
            background: var(--vapor-darker);
            border-top: 1px solid var(--vapor-purple);
            padding: 40px 20px;
            text-align: center;
        }

        .footer-text {
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--vapor-purple);
            font-size: 1rem;
            opacity: 0.7;
        }

        .footer-jp {
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--vapor-pink);
            font-size: 1.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px var(--vapor-pink);
        }

        /* ============================================
           RESPONSIVE
           ============================================ */
        @media (max-width: 768px) {
            .glitch-text {
                font-size: 3rem;
                letter-spacing: 5px;
            }

            .japanese-title {
                font-size: 1.5rem;
                letter-spacing: 8px;
            }

            .subtitle {
                font-size: 1rem;
                letter-spacing: 4px;
            }

            .retro-sun {
                width: 300px;
                height: 300px;
            }

            .vapor-navbar {
                padding: 0 15px;
            }

            .nav-links {
                gap: 15px;
            }

            .nav-links a {
                font-size: 0.7rem;
            }

            .nav-jp {
                display: none;
            }

            .section-title {
                font-size: 1.8rem;
            }

            .ui-overlay {
                flex-direction: column;
                gap: 10px;
            }

            .floating-element {
                display: none;
            }
        }

        /* Reduced Motion */
        @media (prefers-reduced-motion: reduce) {

            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
            }

            html {
                scroll-behavior: auto;
            }
        }

        /* Focus states */
        a:focus,
        button:focus {
            outline: 2px solid var(--vapor-cyan);
            outline-offset: 3px;
        }
    </style>
</head>

<body>
    <!-- Overlay Effects -->
    <div class="crt-overlay"></div>
    <div class="vhs-overlay"></div>
    <div class="vignette"></div>

    <!-- Animated Stars -->
    <div class="stars-container" id="stars"></div>

    <!-- Navbar -->
    <nav class="xp-navbar" role="navigation" aria-label="Main navigation">
        <div class="start-btn" aria-label="Start">
            <div class="w-4 h-4 bg-white relative overflow-hidden mr-2 border border-blue-800 shadow-sm">
                <div class="absolute top-0 left-0 w-1/2 h-1/2 bg-[#F35325]"></div>
                <div class="absolute top-0 right-0 w-1/2 h-1/2 bg-[#81BC06]"></div>
                <div class="absolute bottom-0 left-0 w-1/2 h-1/2 bg-[#05A6F0]"></div>
                <div class="absolute bottom-0 right-0 w-1/2 h-1/2 bg-[#FFBA08]"></div>
            </div>
            <span>start</span>
        </div>
        <div class="xp-nav-links">
            <a href="#hero">System</a>
            <a href="#album-section">Artifacts</a>
            <a href="#player-section">Hardware</a>
        </div>
    </nav>

    <!-- Hero Section -->
    <section id="hero">
        <div class="retro-sun-container">
            <div class="retro-sun"></div>
        </div>
        <div id="hero-canvas"></div>
        <div id="hero-model-layer" aria-hidden="true">
            <div id="hero-model-reveal"></div>
        </div>
        <div class="hero-front-shadow" aria-hidden="true"></div>
        <div class="hero-content">
            <div class="glitch-container">
                <h1 class="glitch-text">VEKTROID</h1>
            </div>
            <p class="japanese-title">フローラルの専門店</p>
            <p class="subtitle">FLORAL SHOPPE // MACINTOSH PLUS</p>
            <p class="scroll-indicator">▼ スクロールして初期化 ▼</p>
        </div>
    </section>

    <!-- Album Section -->
    <section id="album-section">
        <div class="grid-floor"></div>
        <div class="album-top-shadow" aria-hidden="true"></div>
        <h2 class="section-title">ARTIFACT_アーカイブ</h2>
        <p class="section-subtitle">インタラクトして検査する</p>
        <div id="album-canvas"></div>
    </section>

    <!-- Player Section -->
    <section id="player-section">
        <div class="absolute top-24 text-center z-10 pointer-events-none px-4">
            <h2 class="section-title">HARDWARE_ハードウェア</h2>
            <p class="section-subtitle">ドラッグして回転 // ボタンをクリックして操作</p>
        </div>
        <div id="player-canvas"></div>
        <canvas id="audio-visualizer" aria-hidden="true"></canvas>
        <div class="ui-overlay">
            <button class="retro-btn" id="insert-tape-btn">テープを挿入</button>
            <div id="status-display">NO TAPE テープなし</div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="vapor-footer">
        <p class="footer-jp">私はあなたに会いたいです</p>
        <p class="footer-text">© 2024 VEKTROID // ALL RIGHTS RESERVED // 全著作権所有</p>
    </footer>

    <script>
        /* ============================================
           GENERATE ANIMATED STARS
           ============================================ */
        (function () {
            const starsContainer = document.getElementById('stars');
            const numStars = 150;

            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = Math.random() * 3 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.animationDelay = Math.random() * 3 + 's';
                star.style.animationDuration = (Math.random() * 2 + 2) + 's';
                starsContainer.appendChild(star);
            }
        })();

        /* ============================================
           SCENE 1: HERO - VAPORWAVE GRID TERRAIN
           ============================================ */
        (function () {
            const container = document.getElementById('hero-canvas');
            const heroSection = document.getElementById('hero');
            const modelRevealEl = document.getElementById('hero-model-reveal');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x1a0a2e, 0.015);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 300);
            camera.position.set(0, 2, 7.5);
            camera.lookAt(0, 0.2, -18);
            camera.layers.set(0);

            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            // Separate renderer/camera layers for masked content (hero model + pillars)
            const modelCamera = new THREE.PerspectiveCamera(camera.fov, 1, camera.near, camera.far);
            modelCamera.position.copy(camera.position);
            modelCamera.quaternion.copy(camera.quaternion);
            modelCamera.layers.set(1);

            // Pillars get the same clip/scanline mask, but should NOT follow the hero model orbit.
            // Render them with a fixed camera into the same masked container.
            const pillarsCamera = new THREE.PerspectiveCamera(camera.fov, 1, camera.near, camera.far);
            pillarsCamera.position.copy(camera.position);
            pillarsCamera.quaternion.copy(camera.quaternion);
            pillarsCamera.layers.set(2);

            const pillarsRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            pillarsRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            pillarsRenderer.outputEncoding = THREE.sRGBEncoding;

            const modelRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            modelRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            modelRenderer.outputEncoding = THREE.sRGBEncoding;
            if (modelRevealEl) {
                // Append pillars first so the hero model renders on top.
                modelRevealEl.appendChild(pillarsRenderer.domElement);
                modelRevealEl.appendChild(modelRenderer.domElement);
            }

            function resizeModelRenderer() {
                if (!modelRevealEl) return;
                const w = Math.max(1, modelRevealEl.clientWidth);
                const h = Math.max(1, modelRevealEl.clientHeight);
                modelCamera.aspect = w / h;
                modelCamera.updateProjectionMatrix();
                pillarsCamera.aspect = w / h;
                pillarsCamera.updateProjectionMatrix();
                modelRenderer.setSize(w, h);
                pillarsRenderer.setSize(w, h);
            }
            resizeModelRenderer();

            // Lights for the GLB model
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x140021, 0.8);
            hemiLight.position.set(0, 5, 0);
            hemiLight.layers.set(1);
            hemiLight.layers.enable(2);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
            dirLight.position.set(4, 6, 3);
            dirLight.layers.set(1);
            dirLight.layers.enable(2);
            scene.add(dirLight);

            // Marble pillars loaded from GLB (masked like hero model, but rendered with fixed camera)
            const pillarsRoot = new THREE.Group();
            pillarsRoot.layers.set(2);
            scene.add(pillarsRoot);

            const leftPillar = new THREE.Group();
            const rightPillar = new THREE.Group();
            leftPillar.layers.set(2);
            rightPillar.layers.set(2);
            pillarsRoot.add(leftPillar);
            pillarsRoot.add(rightPillar);

            // Lower them so they sit in the scene (closer to the wireframe plane at y=-5)
            const pillarsBaseY = -5.0;
            const pillarsZ = -12;
            const pillarsSideOffset = 6.2 * 3; // ~3x more off to the sides
            leftPillar.position.set(-pillarsSideOffset, pillarsBaseY, pillarsZ);
            rightPillar.position.set(pillarsSideOffset, pillarsBaseY, pillarsZ);

            // Mirror slight twist so they don't look perfectly identical
            leftPillar.rotation.y = 0.3;
            rightPillar.rotation.y = -0.25;

            // Add a little light so marble reads against the background
            const pillarGlowLeft = new THREE.PointLight(0xff71ce, 1.25, 26);
            pillarGlowLeft.position.set(-pillarsSideOffset + 1.5, 1.5, -8);
            pillarGlowLeft.layers.set(2);
            pillarsRoot.add(pillarGlowLeft);
            const pillarGlowRight = new THREE.PointLight(0x01cdfe, 1.25, 26);
            pillarGlowRight.position.set(pillarsSideOffset - 1.5, 1.5, -8);
            pillarGlowRight.layers.set(2);
            pillarsRoot.add(pillarGlowRight);

            (function loadMarblePillars() {
                if (!THREE.GLTFLoader) {
                    console.warn('GLTFLoader not found. Ensure the GLTFLoader script is loaded.');
                    return;
                }

                const loader = new THREE.GLTFLoader();
                loader.load(
                    'source/marble_pillar.glb',
                    (gltf) => {
                        const pillarTemplate = gltf.scene;

                        // Make sure textures look correct under sRGB output.
                        pillarTemplate.traverse((obj) => {
                            obj.layers.set(2);
                            if (!obj.isMesh) return;
                            obj.castShadow = false;
                            obj.receiveShadow = false;
                            if (obj.material && obj.material.map) {
                                obj.material.map.encoding = THREE.sRGBEncoding;
                            }
                        });

                        // Scale to a consistent visual height so it matches the scene.
                        const targetHeight = 10.5;
                        const yStretch = 1.5; // elongate vertically a bit
                        const bbox = new THREE.Box3().setFromObject(pillarTemplate);
                        const size = new THREE.Vector3();
                        bbox.getSize(size);
                        const currentHeight = Math.max(0.001, size.y);
                        const s = targetHeight / currentHeight;

                        const leftInstance = pillarTemplate.clone(true);
                        const rightInstance = pillarTemplate.clone(true);

                        leftInstance.scale.set(s, s * yStretch, s);
                        rightInstance.scale.set(s, s * yStretch, s);

                        // Keep bases on the same y
                        const leftBox = new THREE.Box3().setFromObject(leftInstance);
                        const rightBox = new THREE.Box3().setFromObject(rightInstance);
                        const leftMin = leftBox.min.y;
                        const rightMin = rightBox.min.y;
                        leftInstance.position.y -= leftMin;
                        rightInstance.position.y -= rightMin;

                        leftPillar.add(leftInstance);
                        rightPillar.add(rightInstance);
                    },
                    undefined,
                    (err) => {
                        console.error('Failed to load marble pillar GLB:', err);
                    }
                );
            })();

            // Grid Terrain
            const tileDepth = 40;
            const tileWidth = 200;
            const segmentsW = 18;
            const segmentsD = 10;

            const geometry = new THREE.PlaneGeometry(tileWidth, tileDepth, segmentsW, segmentsD);
            const pos = geometry.attributes.position;

            // Use coefficient that ensures seamless tiling (2π/tileDepth for perfect periodicity)
            const yCoef = (3 * Math.PI) / tileDepth;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);

                let z = 0;
                z += Math.sin(x * 0.08) * 1.5;
                z += Math.cos(x * 0.2 + y * yCoef) * 2;

                const dist = Math.abs(x) / (tileWidth / 2);
                z += Math.pow(dist, 2.5) * 50;

                pos.setZ(i, z);
            }
            geometry.computeVertexNormals();

            // Gradient wireframe material
            const tiles = [];
            const tileMats = [];
            for (let i = 0; i < 4; i++) {
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff71ce,
                    wireframe: true,
                    transparent: true,
                    opacity: 0
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(0, -5, -i * tileDepth);
                scene.add(mesh);
                tiles.push(mesh);
                tileMats.push(material);
            }

            // Load the hero GLB model.
            // Instead of offsetting the rotation axis (which can be fiddly depending on model origin/orientation),
            // we orbit the camera around the model based on scroll.
            const heroModelRoot = new THREE.Group();
            heroModelRoot.layers.set(1);
            heroModelRoot.visible = false;
            scene.add(heroModelRoot);
            let heroModel = null;
            const heroModelCenter = new THREE.Vector3();

            const heroOrbitCenter = new THREE.Vector3(0, -0.25, -2.5);
            let heroOrbitRadius = 7.8;
            let heroOrbitHeight = 1.9;
            let currentOrbitAngle = 0;

            (function loadHeroModel() {
                if (!THREE.GLTFLoader) {
                    console.warn('GLTFLoader not found. Ensure the GLTFLoader script is loaded.');
                    return;
                }

                const loader = new THREE.GLTFLoader();
                loader.load(
                    'source/vaporwave.glb',
                    (gltf) => {
                        heroModel = gltf.scene;

                        // Reasonable default transforms; adjust if your model is huge/tiny.
                        heroModel.scale.setScalar(2.5);

                        // Ensure materials look correct under sRGB output.
                        heroModel.traverse((obj) => {
                            if (!obj.isMesh) return;
                            obj.castShadow = false;
                            obj.receiveShadow = false;
                            if (obj.material && obj.material.map) {
                                obj.material.map.encoding = THREE.sRGBEncoding;
                            }
                            obj.layers.set(1);
                        });

                        // Center the pivot on the model (bounding box center), then move the rotation axis back ~100cm.
                        new THREE.Box3().setFromObject(heroModel).getCenter(heroModelCenter);
                        heroModel.position.sub(heroModelCenter);
                        heroModelRoot.position.copy(heroOrbitCenter);
                        heroModelRoot.add(heroModel);
                        heroModelRoot.visible = true;

                        // Reveal the model line-by-line (mask only covers the model canvas)
                        if (modelRevealEl) {
                            modelRevealEl.classList.add('is-revealing');

                            const durationMs = 1200;
                            const start = performance.now();
                            const stepPx = 6; // controls "line-by-line" feel

                            const tick = (now) => {
                                const t = Math.max(0, Math.min(1, (now - start) / durationMs));
                                const h = Math.max(1, modelRevealEl.clientHeight);
                                const revealed = Math.floor((h * t) / stepPx) * stepPx;
                                const topPx = Math.max(0, Math.round(h - revealed));
                                modelRevealEl.style.clipPath = `inset(${topPx}px 0px 0px 0px)`;

                                if (t < 1) {
                                    requestAnimationFrame(tick);
                                } else {
                                    modelRevealEl.style.clipPath = 'inset(0px 0px 0px 0px)';
                                    // fade scanlines out shortly after full reveal
                                    setTimeout(() => modelRevealEl.classList.remove('is-revealing'), 350);
                                }
                            };
                            requestAnimationFrame(tick);
                        }
                    },
                    undefined,
                    (err) => {
                        console.error('Failed to load hero GLB:', err);
                    }
                );
            })();

            let time = 0;

            function smoothstep(edge0, edge1, x) {
                const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
                return t * t * (3 - 2 * t);
            }

            function clamp01(x) {
                return Math.max(0, Math.min(1, x));
            }

            function getPageScrollProgress() {
                const doc = document.documentElement;
                const maxScroll = Math.max(1, doc.scrollHeight - window.innerHeight);
                return clamp01(window.scrollY / maxScroll);
            }

            // Pause hero rendering when off-screen / tab hidden (performance)
            let heroRaf = 0;
            let heroIsRunning = false;
            let heroInView = true;

            function heroLoop() {
                if (!heroIsRunning) return;
                heroRaf = requestAnimationFrame(heroLoop);

                time += 0.01;

                // Orbit ONLY the model camera so the wireframe terrain stays stable.
                // (Main camera remains fixed, keeping the background orientation consistent.)
                if (heroModelRoot && heroModelRoot.visible) {
                    const p = getPageScrollProgress();
                    // 2 full orbits across the full page.
                    const targetAngle = 3 * p * Math.PI * 4 + Math.PI / 2;
                    currentOrbitAngle += (targetAngle - currentOrbitAngle) * 0.12;

                    const x = heroOrbitCenter.x + Math.cos(currentOrbitAngle) * heroOrbitRadius;
                    const z = heroOrbitCenter.z + Math.sin(currentOrbitAngle) * heroOrbitRadius;

                    modelCamera.position.set(x, heroOrbitCenter.y + heroOrbitHeight, z);
                    modelCamera.lookAt(heroOrbitCenter.x, heroOrbitCenter.y, heroOrbitCenter.z);

                    // Subtle idle tilt on the model itself for depth.
                    if (heroModel) heroModel.rotation.x = -0.05 + Math.sin(time * 0.3) * 0.02;
                }

                const speed = 0.12;
                tiles.forEach(tile => {
                    tile.position.z += speed;
                    if (tile.position.z >= tileDepth) {
                        tile.position.z -= tileDepth * 4;
                    }
                });

                // Pillars: automatic spin + half-scroll parallax (semi-fixed feel)
                // Use hero section's top offset so effect is tied to the section while it's on screen.
                if (pillarsRoot && heroSection) {
                    // Auto spin
                    leftPillar.rotation.y += 0.007;
                    rightPillar.rotation.y -= 0.008;

                    const rectTopPx = heroSection.getBoundingClientRect().top;
                    const depth = Math.max(0.1, Math.abs(camera.position.z - pillarsZ));
                    const worldHeightAtDepth = 2 * depth * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5));
                    const worldPerPx = worldHeightAtDepth / Math.max(1, window.innerHeight);

                    // Compensate ~50% of scroll movement (correct direction)
                    const parallaxY = (rectTopPx) * 0.5 * worldPerPx;
                    pillarsRoot.position.y = parallaxY;
                }

                // Color cycling
                const hue = (Math.sin(time * 0.5) + 1) / 2;
                tileMats.forEach((mat, idx) => {
                    mat.color.setHSL(hue * 0.1 + 0.85, 1, 0.6);

                    // Distance-based fade: far tiles spawn fully transparent
                    const z = tiles[idx].position.z;
                    const farZ = -tileDepth * 3.0;   // most distant tile start
                    const nearZ = tileDepth * 0.35;  // closer region becomes opaque
                    const opacity = smoothstep(farZ, nearZ, z);
                    mat.opacity = opacity;
                });


                renderer.render(scene, camera);
                // Render masked pillars with a fixed camera (so they don't orbit with the hero model)
                pillarsCamera.position.copy(camera.position);
                pillarsCamera.quaternion.copy(camera.quaternion);
                pillarsRenderer.render(scene, pillarsCamera);
                modelRenderer.render(scene, modelCamera);
            }

            function heroStart() {
                if (heroIsRunning) return;
                heroIsRunning = true;
                heroRaf = requestAnimationFrame(heroLoop);
            }

            function heroStop() {
                heroIsRunning = false;
                if (heroRaf) cancelAnimationFrame(heroRaf);
                heroRaf = 0;
            }

            function heroUpdateRunning() {
                const shouldRun = heroInView && !document.hidden;
                if (shouldRun) heroStart();
                else heroStop();
            }

            if (heroSection) {
                const heroObserver = new IntersectionObserver(
                    (entries) => {
                        heroInView = entries.some(e => e.isIntersecting);
                        heroUpdateRunning();
                    },
                    { threshold: 0.05 }
                );
                heroObserver.observe(heroSection);
            }
            document.addEventListener('visibilitychange', heroUpdateRunning);
            heroUpdateRunning();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);

                modelCamera.fov = camera.fov;
                modelCamera.near = camera.near;
                modelCamera.far = camera.far;
                pillarsCamera.fov = camera.fov;
                pillarsCamera.near = camera.near;
                pillarsCamera.far = camera.far;
                resizeModelRenderer();
            });
        })();

        /* ============================================
           SCENE 2: ALBUM - FLOATING BUST & GLASS
           ============================================ */
        (function () {
            const container = document.getElementById('album-canvas');
            const width = container.clientWidth;
            const height = container.clientHeight;

            const albumSection = document.getElementById('album-section');

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 100);
            camera.position.z = 7;

            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(width, height);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            // Vaporwave Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);

            const pinkLight = new THREE.PointLight(0xff71ce, 3, 20);
            pinkLight.position.set(5, 5, 5);
            scene.add(pinkLight);

            const cyanLight = new THREE.PointLight(0x01cdfe, 3, 20);
            cyanLight.position.set(-5, -3, 5);
            scene.add(cyanLight);

            const purpleLight = new THREE.PointLight(0xb967ff, 2, 15);
            purpleLight.position.set(0, 5, -5);
            scene.add(purpleLight);

            // Vaporwave Art Generator
            function generateVaporwaveArt() {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');

                // Gradient background
                const gradient = ctx.createLinearGradient(0, 0, 512, 512);
                gradient.addColorStop(0, '#ff71ce');
                gradient.addColorStop(0.5, '#b967ff');
                gradient.addColorStop(1, '#01cdfe');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);

                // Grid lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 512; i += 30) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(512, i);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, 512);
                    ctx.stroke();
                }

                // Japanese text
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 40px "Noto Sans JP", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('フローラル', 256, 200);
                ctx.fillText('専門店', 256, 260);

                // English text
                ctx.font = 'bold 30px Orbitron, sans-serif';
                ctx.fillText('VEKTROID', 256, 350);

                return new THREE.CanvasTexture(canvas);
            }

            const pivot = new THREE.Group();
            scene.add(pivot);

            // Album Art
            const albumGeo = new THREE.BoxGeometry(2.5, 2.5, 0.15);
            const albumMat = new THREE.MeshStandardMaterial({
                map: generateVaporwaveArt(),
                emissive: 0x333333,
                roughness: 0.3,
                metalness: 0.1
            });
            const album = new THREE.Mesh(albumGeo, albumMat);
            pivot.add(album);

            // Glass Cube
            const glassGeo = new THREE.BoxGeometry(3, 3, 3);
            const glassMat = new THREE.MeshPhysicalMaterial({
                roughness: 0.05,
                metalness: 0,
                transmission: 0.9,
                thickness: 0.5,
                ior: 1.5,
                clearcoat: 1,
                clearcoatRoughness: 0.1,
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            });
            const glass = new THREE.Mesh(glassGeo, glassMat);
            pivot.add(glass);

            // Add floating particles
            const particleGeo = new THREE.BufferGeometry();
            const particleCount = 100;
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 10;
                positions[i + 1] = (Math.random() - 0.5) * 10;
                positions[i + 2] = (Math.random() - 0.5) * 10;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMat = new THREE.PointsMaterial({
                color: 0xff71ce,
                size: 0.05,
                transparent: true,
                opacity: 0.6
            });
            const particles = new THREE.Points(particleGeo, particleMat);
            scene.add(particles);

            // Interaction
            let isDragging = false;
            let pointerId = null;
            let previousPointer = { x: 0, y: 0 };
            let rotVel = { x: 0, y: 0 };
            const dragSensitivity = 0.008;
            const damping = 0.92;

            container.style.touchAction = 'none';

            container.addEventListener('pointerdown', (e) => {
                isDragging = true;
                pointerId = e.pointerId;
                container.setPointerCapture(pointerId);
                previousPointer = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('pointerup', () => {
                isDragging = false;
                pointerId = null;
            });

            container.addEventListener('pointercancel', () => {
                isDragging = false;
                pointerId = null;
            });

            container.addEventListener('pointermove', (e) => {
                if (!isDragging || e.pointerId !== pointerId) return;
                const deltaX = e.clientX - previousPointer.x;
                const deltaY = e.clientY - previousPointer.y;
                const vx = deltaY * dragSensitivity;
                const vy = deltaX * dragSensitivity;

                pivot.rotation.x += vx;
                pivot.rotation.y += vy;

                rotVel.x = vx;
                rotVel.y = vy;
                previousPointer = { x: e.clientX, y: e.clientY };
            });

            function lerp(a, b, t) {
                return a + (b - a) * t;
            }

            // Pause album rendering when off-screen / tab hidden (performance)
            let albumRaf = 0;
            let albumIsRunning = false;
            let albumInView = true;

            function albumLoop() {
                if (!albumIsRunning) return;
                albumRaf = requestAnimationFrame(albumLoop);

                const t = Date.now() * 0.001;

                if (!isDragging) {
                    // Inertia
                    pivot.rotation.x += rotVel.x;
                    pivot.rotation.y += rotVel.y;
                    rotVel.x *= damping;
                    rotVel.y *= damping;

                    // Subtle idle motion when inertia is low
                    const inertiaMag = Math.abs(rotVel.x) + Math.abs(rotVel.y);
                    if (inertiaMag < 0.0008) {
                        const targetX = Math.sin(t * 0.3) * 0.1;
                        pivot.rotation.y += 0.003;
                        pivot.rotation.x = lerp(pivot.rotation.x, targetX, 0.03);
                    }
                }

                // Animate particles
                particles.rotation.y += 0.001;
                particles.rotation.x += 0.0005;

                // Animate lights
                pinkLight.position.x = Math.sin(t) * 5;
                cyanLight.position.y = Math.cos(t * 0.7) * 5;

                renderer.render(scene, camera);
            }

            function albumStart() {
                if (albumIsRunning) return;
                albumIsRunning = true;
                albumRaf = requestAnimationFrame(albumLoop);
            }

            function albumStop() {
                albumIsRunning = false;
                if (albumRaf) cancelAnimationFrame(albumRaf);
                albumRaf = 0;
            }

            function albumUpdateRunning() {
                const shouldRun = albumInView && !document.hidden;
                if (shouldRun) albumStart();
                else albumStop();
            }

            if (albumSection) {
                const albumObserver = new IntersectionObserver(
                    (entries) => {
                        albumInView = entries.some(e => e.isIntersecting);
                        albumUpdateRunning();
                    },
                    { threshold: 0.05 }
                );
                albumObserver.observe(albumSection);
            }
            document.addEventListener('visibilitychange', albumUpdateRunning);
            albumUpdateRunning();

            window.addEventListener('resize', () => {
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            });
        })();

        /* ============================================
           SCENE 3: VAPORWAVE CASSETTE PLAYER
           ============================================ */
        (function () {
            const container = document.getElementById('player-canvas');
            const visualizerCanvas = document.getElementById('audio-visualizer');
            const playerSection = document.getElementById('player-section');
            let width = container.clientWidth;
            let height = container.clientHeight;

            const scene = new THREE.Scene();
            // Transparent so the canvas visualizer can show through behind the 3D.
            scene.background = null;

            const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
            camera.position.set(8, 5, 8);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(width, height);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Vaporwave Lighting
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const pinkLight = new THREE.PointLight(0xff71ce, 2, 20);
            pinkLight.position.set(-5, 3, 5);
            scene.add(pinkLight);

            const cyanLight = new THREE.PointLight(0x01cdfe, 2, 20);
            cyanLight.position.set(5, 3, -5);
            scene.add(cyanLight);

            const ambLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambLight);

            // Grid Floor
            const gridHelper = new THREE.GridHelper(20, 20, 0xff71ce, 0x01cdfe);
            gridHelper.position.y = -3;
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            const playerGroup = new THREE.Group();
            scene.add(playerGroup);

            // Materials with vaporwave colors
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                roughness: 0.3,
                metalness: 0.5
            });
            const accentMat = new THREE.MeshStandardMaterial({
                color: 0xff71ce,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0xff71ce,
                emissiveIntensity: 0.2
            });
            const windowMat = new THREE.MeshPhysicalMaterial({
                color: 0x111111,
                transmission: 0.8,
                thickness: 1,
                roughness: 0.1
            });
            const innerDarkMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const chassisGroup = new THREE.Group();
            playerGroup.add(chassisGroup);

            // Back Plate
            const back = new THREE.Mesh(new THREE.BoxGeometry(4.5, 5.5, 0.5), bodyMat);
            back.position.z = -0.8;
            back.castShadow = true;
            chassisGroup.add(back);

            // Accent strips
            const stripGeo = new THREE.BoxGeometry(4.6, 0.1, 0.6);
            const topStrip = new THREE.Mesh(stripGeo, accentMat);
            topStrip.position.set(0, 2.5, 0);
            chassisGroup.add(topStrip);

            const bottomStrip = new THREE.Mesh(stripGeo, accentMat);
            bottomStrip.position.set(0, -2.5, 0);
            chassisGroup.add(bottomStrip);

            // Dark inner void
            const voidBox = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2.8, 0.1), innerDarkMat);
            voidBox.position.set(0, 0.25, -0.54);
            chassisGroup.add(voidBox);

            // Bottom Block
            const bottom = new THREE.Mesh(new THREE.BoxGeometry(4.5, 1.5, 1.5), bodyMat);
            bottom.position.set(0, -1.75, 0);
            bottom.castShadow = true;
            chassisGroup.add(bottom);

            // Top Block
            const top = new THREE.Mesh(new THREE.BoxGeometry(4.5, 1, 1.5), bodyMat);
            top.position.set(0, 2, 0);
            top.castShadow = true;
            chassisGroup.add(top);

            // Sides
            const left = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.75, 1.5), bodyMat);
            left.position.set(-1.95, 0.125, 0);
            chassisGroup.add(left);

            const right = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.75, 1.5), bodyMat);
            right.position.set(1.95, 0.125, 0);
            chassisGroup.add(right);

            // Door Frame
            const doorGroup = new THREE.Group();
            doorGroup.position.set(0, 0.25, 0.75);
            playerGroup.add(doorGroup);

            const glassPanel = new THREE.Mesh(new THREE.BoxGeometry(3.0, 2.0, 0.05), windowMat);
            doorGroup.add(glassPanel);

            // Vaporwave Buttons
            const buttons = [];
            const btnColors = [0xff71ce, 0x01cdfe, 0xb967ff, 0x05ffa1];

            function createBtn(x, colorIndex, name) {
                const geo = new THREE.BoxGeometry(0.8, 0.3, 0.4);
                const mat = new THREE.MeshStandardMaterial({
                    color: btnColors[colorIndex],
                    emissive: btnColors[colorIndex],
                    emissiveIntensity: 0.3,
                    roughness: 0.2,
                    metalness: 0.8
                });
                const btn = new THREE.Mesh(geo, mat);
                btn.position.set(x, 2.65, 0);
                btn.castShadow = true;
                btn.userData = { isButton: true, name: name, originalY: 2.65 };
                playerGroup.add(btn);
                buttons.push(btn);
            }

            createBtn(-1.5, 0, 'stop');
            createBtn(-0.5, 1, 'rewind');
            createBtn(0.5, 2, 'play');
            createBtn(1.5, 3, 'ff');

            // Cassette Tape with vaporwave styling
            const tapeGroup = new THREE.Group();
            const tapeBody = new THREE.Mesh(
                new THREE.BoxGeometry(3, 1.8, 0.3),
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 })
            );

            // Gradient label
            const labelCanvas = document.createElement('canvas');
            labelCanvas.width = 256;
            labelCanvas.height = 64;
            const labelCtx = labelCanvas.getContext('2d');
            const labelGradient = labelCtx.createLinearGradient(0, 0, 256, 0);
            labelGradient.addColorStop(0, '#ff71ce');
            labelGradient.addColorStop(0.5, '#b967ff');
            labelGradient.addColorStop(1, '#01cdfe');
            labelCtx.fillStyle = labelGradient;
            labelCtx.fillRect(0, 0, 256, 64);
            labelCtx.fillStyle = 'white';
            labelCtx.font = 'bold 20px sans-serif';
            labelCtx.textAlign = 'center';
            labelCtx.fillText('FLORAL SHOPPE', 128, 40);

            const labelTexture = new THREE.CanvasTexture(labelCanvas);
            const tapeLabel = new THREE.Mesh(
                new THREE.BoxGeometry(2.8, 0.5, 0.32),
                new THREE.MeshBasicMaterial({ map: labelTexture })
            );
            tapeLabel.position.y = 0.5;
            tapeGroup.add(tapeBody);
            tapeGroup.add(tapeLabel);

            // Tape Reels
            const reelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.35, 16);
            const reelMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.3,
                metalness: 0.7
            });
            const leftReel = new THREE.Mesh(reelGeo, reelMat);
            const rightReel = new THREE.Mesh(reelGeo, reelMat);
            leftReel.rotation.x = Math.PI / 2;
            rightReel.rotation.x = Math.PI / 2;
            leftReel.position.set(-0.8, -0.2, 0.1);
            rightReel.position.set(0.8, -0.2, 0.1);

            const tooth = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.4, 0.1),
                new THREE.MeshBasicMaterial({ color: 0x000 })
            );
            leftReel.add(tooth);
            rightReel.add(tooth.clone());
            tapeGroup.add(leftReel);
            tapeGroup.add(rightReel);

            // Keep the tape in playerGroup local space so it always matches rotation
            tapeGroup.position.set(6, 0.25, 0);
            playerGroup.add(tapeGroup);

            // Interaction
            let isDragging = false;
            let pointerId = null;
            let previousPointer = { x: 0, y: 0 };
            let rotVel = { x: 0, y: 0 };
            const dragSensitivity = 0.01;
            const damping = 0.9;
            let tapeInserted = false;
            let isPlaying = false;

            // ==========================
            // AUDIO: FloralShoppeCassette
            // ==========================
            const statusEl = document.getElementById('status-display');
            const audioEl = new Audio();
            audioEl.preload = 'metadata';
            audioEl.loop = false;

            // Keep this list in sync with the files in FloralShoppeCassette/
            const tapePlaylist = [
                { title: 'A1 ブート', audio: 'FloralShoppeCassette/A1 ブート.mp3', cover: 'FloralShoppeCassette/A1 ブート.png' },
                { title: 'A2 リサフランク420 現代のコンピュー', audio: 'FloralShoppeCassette/A2 リサフランク420 現代のコンピュー.mp3', cover: 'FloralShoppeCassette/A2 リサフランク420 現代のコンピュー.png' },
                { title: 'A3 花の専門店', audio: 'FloralShoppeCassette/A3 花の専門店.mp3', cover: 'FloralShoppeCassette/A3 花の専門店.png' },
                { title: 'A4 ライブラリ', audio: 'FloralShoppeCassette/A4 ライブラリ.mp3', cover: 'FloralShoppeCassette/A4 ライブラリ.png' },
                { title: 'A5 地理', audio: 'FloralShoppeCassette/A5 地理.mp3', cover: 'FloralShoppeCassette/A5 地理.png' },
                { title: 'B1 Eccoと悪寒ダイビング', audio: 'FloralShoppeCassette/B1 Eccoと悪寒ダイビング.mp3', cover: 'FloralShoppeCassette/B1 Eccoと悪寒ダイビング.png' },
                { title: 'B2 数学', audio: 'FloralShoppeCassette/B2 数学.mp3', cover: 'FloralShoppeCassette/B2 数学.png' },
                { title: 'B3 待機', audio: 'FloralShoppeCassette/B3 待機.mp3', cover: 'FloralShoppeCassette/B3 待機.png' },
                { title: 'B4 ピコ', audio: 'FloralShoppeCassette/B4 ピコ.mp3', cover: 'FloralShoppeCassette/B4 ピコ.png' },
                { title: 'B5 外ギン Aviation', audio: 'FloralShoppeCassette/B5 外ギン Aviation.mp3', cover: 'FloralShoppeCassette/B5 外ギン Aviation.png' },
                { title: 'B6 て', audio: 'FloralShoppeCassette/B6 て.mp3', cover: 'FloralShoppeCassette/B6 て.png' },
            ];

            let currentTrackIndex = 0;

            let audioCtx = null;
            let analyser = null;
            let analyserData = null;
            let audioSource = null;
            let vizRaf = 0;

            function ensureAudioGraph() {
                if (audioCtx && analyser && audioSource) return;
                const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
                if (!AudioContextCtor) {
                    console.warn('Web Audio API not available; visualizer disabled.');
                    return;
                }
                audioCtx = new AudioContextCtor();
                analyser = audioCtx.createAnalyser();
                // Lower fftSize + smoothing = less CPU + less "glitch"/jitter.
                analyser.fftSize = 1024;
                analyser.smoothingTimeConstant = 0.86;
                analyserData = new Uint8Array(analyser.frequencyBinCount);
                audioSource = audioCtx.createMediaElementSource(audioEl);
                audioSource.connect(analyser);
                analyser.connect(audioCtx.destination);
            }

            function setStatus(text, color) {
                if (!statusEl) return;
                statusEl.innerText = text;
                if (color) statusEl.style.color = color;
            }

            function setTapeLabel(track) {
                // Draw cover + title onto the existing label canvas
                const ctx = labelCtx;
                if (!ctx) return;

                ctx.clearRect(0, 0, labelCanvas.width, labelCanvas.height);

                // gradient base
                const g = ctx.createLinearGradient(0, 0, labelCanvas.width, 0);
                g.addColorStop(0, '#ff71ce');
                g.addColorStop(0.5, '#b967ff');
                g.addColorStop(1, '#01cdfe');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, labelCanvas.width, labelCanvas.height);

                // title
                ctx.fillStyle = 'rgba(255,255,255,0.95)';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(track?.title ? track.title : 'FLORAL SHOPPE', 128, 40);

                labelTexture.needsUpdate = true;

                // Load cover into a THREE texture and swap on the tape body/label if desired
                // (Keeping it minimal here: label text updates instantly even if cover fails.)
            }

            function loadTrack(index) {
                currentTrackIndex = (index + tapePlaylist.length) % tapePlaylist.length;
                const track = tapePlaylist[currentTrackIndex];

                // encodeURI keeps japanese + spaces safe for URL paths
                audioEl.src = encodeURI(track.audio);
                setTapeLabel(track);
                setStatus(`READY 準備完了\n${track.title}`, '#01cdfe');
            }

            async function playCurrent() {
                if (!tapeInserted) {
                    setStatus('NO TAPE テープなし', '#ff71ce');
                    return;
                }

                ensureAudioGraph();
                if (audioCtx && audioCtx.state === 'suspended') {
                    try { await audioCtx.resume(); } catch (_) { }
                }

                try {
                    await audioEl.play();
                    isPlaying = true;
                    setStatus(`再生中 PLAYING >>\n${tapePlaylist[currentTrackIndex].title}`, '#05ffa1');
                    startVisualizer();
                } catch (e) {
                    console.warn('Audio play failed (autoplay restriction or missing file):', e);
                    isPlaying = false;
                    setStatus('PLAY FAILED 再生失敗', '#ff71ce');
                    stopVisualizer();
                }
            }

            function stopPlayback() {
                audioEl.pause();
                audioEl.currentTime = 0;
                isPlaying = false;
                setStatus(`停止 STOPPED\n${tapePlaylist[currentTrackIndex]?.title ?? ''}`, '#ff71ce');
                stopVisualizer();
            }

            function pausePlayback() {
                audioEl.pause();
                isPlaying = false;
                setStatus(`一時停止 PAUSED\n${tapePlaylist[currentTrackIndex]?.title ?? ''}`, '#b967ff');
                stopVisualizer();
            }

            function nextTrack() {
                loadTrack(currentTrackIndex + 1);
                if (tapeInserted && isPlaying) playCurrent();
            }

            function prevTrack() {
                loadTrack(currentTrackIndex - 1);
                if (tapeInserted && isPlaying) playCurrent();
            }

            audioEl.addEventListener('ended', () => {
                // Autoplay next track when current ends
                nextTrack();
            });

            // ================
            // VISUALIZER (REWORKED)
            // ================
            const visualizer = (() => {
                if (!visualizerCanvas) return null;
                const ctx = visualizerCanvas.getContext('2d', { alpha: true, desynchronized: true });
                if (!ctx) return null;

                const TARGET_FPS = 60;
                const FRAME_MS = 1000 / TARGET_FPS;
                const SAMPLES = 256;
                const AUDIO_WAVE_GAIN = 10;

                let running = false;
                let raf = 0;
                let lastFrameMs = 0;

                let dpr = 1;
                let cssW = 1;
                let cssH = 1;

                let timeFloat = null;
                let timeByte = null;
                let freqByte = null;
                const down = new Float32Array(SAMPLES);
                const smooth = new Float32Array(SAMPLES);

                // Pre-rendered background (radial + scanlines) rebuilt only on resize
                const bg = document.createElement('canvas');
                const bgCtx = bg.getContext('2d');

                function rebuildBackground() {
                    if (!bgCtx) return;
                    bg.width = Math.max(1, cssW);
                    bg.height = Math.max(1, cssH);

                    bgCtx.clearRect(0, 0, bg.width, bg.height);

                    // Soft radial neon "sun" behind everything
                    const r = Math.max(bg.width, bg.height) * 0.55;
                    const cx = bg.width * 0.5;
                    const cy = bg.height * 0.52;
                    const g = bgCtx.createRadialGradient(cx, cy, 0, cx, cy, r);
                    g.addColorStop(0, 'rgba(1, 205, 254, 0.14)');
                    g.addColorStop(0.35, 'rgba(185, 103, 255, 0.08)');
                    g.addColorStop(0.7, 'rgba(255, 113, 206, 0.05)');
                    g.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    bgCtx.fillStyle = g;
                    bgCtx.fillRect(0, 0, bg.width, bg.height);

                    // Thin scanlines (cheap, static)
                    bgCtx.globalCompositeOperation = 'screen';
                    bgCtx.fillStyle = 'rgba(255,255,255,0.025)';
                    for (let y = 0; y < bg.height; y += 4) bgCtx.fillRect(0, y, bg.width, 1);
                    bgCtx.globalCompositeOperation = 'source-over';
                }

                function resize() {
                    const rect = container ? container.getBoundingClientRect() : visualizerCanvas.getBoundingClientRect();
                    cssW = Math.max(1, Math.floor(rect.width));
                    cssH = Math.max(1, Math.floor(rect.height));
                    dpr = Math.min(window.devicePixelRatio || 1, 2);

                    visualizerCanvas.style.width = cssW + 'px';
                    visualizerCanvas.style.height = cssH + 'px';
                    visualizerCanvas.width = Math.floor(cssW * dpr);
                    visualizerCanvas.height = Math.floor(cssH * dpr);
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                    rebuildBackground();
                }

                function sampleTimeDomain(tSeconds) {
                    const audioActive = !!(analyser && isPlaying && !audioEl.paused);

                    if (audioActive) {
                        // Prefer float data for smoother visuals.
                        if (typeof analyser.getFloatTimeDomainData === 'function') {
                            if (!timeFloat || timeFloat.length !== analyser.fftSize) timeFloat = new Float32Array(analyser.fftSize);
                            analyser.getFloatTimeDomainData(timeFloat);

                            const step = timeFloat.length / SAMPLES;
                            for (let i = 0; i < SAMPLES; i++) {
                                // RMS-ish sampling over a small window to reduce jitter
                                const start = Math.floor(i * step);
                                const end = Math.min(timeFloat.length, Math.floor((i + 1) * step));
                                let acc = 0;
                                let count = 0;
                                for (let j = start; j < end; j++) {
                                    const v = timeFloat[j];
                                    acc += v;
                                    count++;
                                }
                                down[i] = count ? (acc / count) : 0;
                            }
                        } else {
                            if (!timeByte || timeByte.length !== analyser.fftSize) timeByte = new Uint8Array(analyser.fftSize);
                            analyser.getByteTimeDomainData(timeByte);
                            const step = timeByte.length / SAMPLES;
                            for (let i = 0; i < SAMPLES; i++) {
                                down[i] = ((timeByte[Math.floor(i * step)] - 128) / 128);
                            }
                        }
                    } else {
                        // Idle: lissajous-style ribbon (stable, smooth)
                        for (let i = 0; i < SAMPLES; i++) {
                            const p = i / (SAMPLES - 1);
                            const a = Math.sin(p * Math.PI * 6 + tSeconds * 1.6) * 0.55;
                            const b = Math.sin(p * Math.PI * 2 - tSeconds * 0.9) * 0.25;
                            const c = Math.sin(p * Math.PI * 12 + tSeconds * 0.35) * 0.12;
                            down[i] = (a + b + c) * 0.85;
                        }
                    }

                    // Boost audio amplitude (keep idle unchanged)
                    if (audioActive) {
                        for (let i = 0; i < SAMPLES; i++) {
                            const v = down[i] * AUDIO_WAVE_GAIN;
                            down[i] = Math.max(-1, Math.min(1, v));
                        }
                    }

                    // Critically damped smoothing for stability
                    const follow = audioActive ? 0.22 : 0.12;
                    for (let i = 0; i < SAMPLES; i++) {
                        smooth[i] = smooth[i] + (down[i] - smooth[i]) * follow;
                    }

                    // Frequency data for a subtle bottom haze (optional)
                    if (audioActive && analyserData) {
                        if (!freqByte || freqByte.length !== analyserData.length) freqByte = analyserData;
                        analyser.getByteFrequencyData(freqByte);
                        visualizerCanvas.classList.add('is-active');
                    } else {
                        visualizerCanvas.classList.remove('is-active');
                    }
                }

                function drawWave(tSeconds) {
                    // Background
                    ctx.clearRect(0, 0, cssW, cssH);
                    ctx.drawImage(bg, 0, 0, cssW, cssH);

                    // Wave ribbon
                    const mid = cssH * 0.56;
                    const amp = cssH * 0.34;

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';

                    // Glow passes (big -> small)
                    const passes = [
                        { w: 14, a: 0.08, c: 'rgba(255, 113, 206, 1)', blur: 24 },
                        { w: 7, a: 0.16, c: 'rgba(185, 103, 255, 1)', blur: 16 },
                        { w: 3, a: 0.9, c: 'rgba(1, 205, 254, 1)', blur: 8 },
                    ];

                    for (const p of passes) {
                        ctx.beginPath();
                        ctx.lineWidth = p.w;
                        ctx.strokeStyle = p.c;
                        ctx.globalAlpha = p.a;
                        ctx.shadowColor = p.c;
                        ctx.shadowBlur = p.blur;

                        // Quadratic smoothing
                        let x0 = 0;
                        let y0 = mid + smooth[0] * amp;
                        ctx.moveTo(x0, y0);

                        for (let i = 1; i < SAMPLES; i++) {
                            const x = (i / (SAMPLES - 1)) * cssW;
                            const y = mid + smooth[i] * amp;
                            const cx = (x0 + x) * 0.5;
                            const cy = (y0 + y) * 0.5;
                            ctx.quadraticCurveTo(x0, y0, cx, cy);
                            x0 = x;
                            y0 = y;
                        }
                        ctx.lineTo(cssW, y0);
                        ctx.stroke();
                    }

                    ctx.restore();

                    // Subtle spectral haze at the bottom (cheap rectangles)
                    const audioActive = !!(freqByte && analyser && isPlaying && !audioEl.paused);
                    const hazeCount = 48;
                    const hazeW = cssW / hazeCount;
                    const baseY = cssH * 0.92;
                    ctx.save();
                    ctx.globalCompositeOperation = 'screen';
                    ctx.globalAlpha = 0.45;
                    for (let i = 0; i < hazeCount; i++) {
                        const v = audioActive
                            ? (freqByte[Math.min(freqByte.length - 1, i * 2)] / 255)
                            : (0.35 + 0.25 * Math.sin(tSeconds * 0.8 + i * 0.25));
                        const h = (0.18 + Math.pow(v, 0.9) * 0.9) * (cssH * 0.35);
                        const x = i * hazeW;
                        ctx.fillStyle = i % 3 === 0
                            ? 'rgba(255, 113, 206, 0.25)'
                            : (i % 3 === 1 ? 'rgba(185, 103, 255, 0.22)' : 'rgba(1, 205, 254, 0.22)');
                        ctx.fillRect(x + 1, baseY - h, Math.max(1, hazeW - 2), h);
                    }
                    ctx.restore();
                }

                function tick(nowMs) {
                    if (!running) return;
                    raf = requestAnimationFrame(tick);

                    if (nowMs - lastFrameMs < FRAME_MS) return;
                    lastFrameMs = nowMs;

                    // Keep canvas size stable; only resize when needed.
                    const rect = container ? container.getBoundingClientRect() : visualizerCanvas.getBoundingClientRect();
                    const nextW = Math.max(1, Math.floor(rect.width));
                    const nextH = Math.max(1, Math.floor(rect.height));
                    const nextDpr = Math.min(window.devicePixelRatio || 1, 2);
                    if (nextW !== cssW || nextH !== cssH || nextDpr !== dpr) resize();

                    const t = nowMs * 0.001;
                    sampleTimeDomain(t);
                    drawWave(t);
                }

                function start() {
                    if (running) return;
                    running = true;
                    resize();
                    lastFrameMs = performance.now();
                    raf = requestAnimationFrame(tick);
                }

                function stop(clear = false) {
                    running = false;
                    if (raf) cancelAnimationFrame(raf);
                    raf = 0;
                    if (clear) ctx.clearRect(0, 0, cssW, cssH);
                }

                return { start, stop, resize };
            })();

            function resizeVisualizerCanvas() {
                visualizer?.resize();
            }

            function startVisualizer() {
                visualizer?.start();
            }

            function stopVisualizer(offscreen) {
                // If offscreen, fully stop + clear. Otherwise keep it visible (idle mode).
                if (offscreen) visualizer?.stop(true);
            }

            // Pause 3D render + visualizer when off-screen / tab hidden
            let playerRaf = 0;
            let playerIsRunning = false;
            let playerInView = true;

            function playerLoop() {
                if (!playerIsRunning) return;
                playerRaf = requestAnimationFrame(playerLoop);

                const t = Date.now() * 0.001;

                if (!isDragging) {
                    // Inertia
                    playerGroup.rotation.x += rotVel.x;
                    playerGroup.rotation.y += rotVel.y;
                    playerGroup.rotation.x = Math.max(-0.9, Math.min(0.6, playerGroup.rotation.x));
                    rotVel.x *= damping;
                    rotVel.y *= damping;
                }

                renderer.render(scene, camera);

                if (tapeInserted && isPlaying) {
                    leftReel.rotation.y -= 0.1;
                    rightReel.rotation.y -= 0.1;
                }

                // Animate lights
                pinkLight.position.x = Math.sin(t * 0.5) * 5;
                cyanLight.position.z = Math.cos(t * 0.5) * 5;

                // Subtle grid animation
                gridHelper.rotation.y += 0.001;
            }

            function playerStart() {
                if (playerIsRunning) return;
                playerIsRunning = true;
                playerRaf = requestAnimationFrame(playerLoop);
            }

            function playerStop() {
                playerIsRunning = false;
                if (playerRaf) cancelAnimationFrame(playerRaf);
                playerRaf = 0;
            }

            function playerUpdateRunning() {
                const shouldRun = playerInView && !document.hidden;
                if (shouldRun) {
                    playerStart();
                    // Always show the oscillator as a background when the cassette area is visible.
                    startVisualizer();
                } else {
                    playerStop();
                    // Keep audio playing, but stop drawing the visualizer when off-screen.
                    stopVisualizer(true);
                }
            }

            if (playerSection) {
                const playerObserver = new IntersectionObserver(
                    (entries) => {
                        playerInView = entries.some(e => e.isIntersecting);
                        playerUpdateRunning();
                    },
                    { threshold: 0.05 }
                );
                playerObserver.observe(playerSection);
            }
            document.addEventListener('visibilitychange', playerUpdateRunning);

            container.style.touchAction = 'none';

            container.addEventListener('pointerdown', (e) => {
                isDragging = true;
                pointerId = e.pointerId;
                container.setPointerCapture(pointerId);
                previousPointer = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('pointerup', () => {
                isDragging = false;
                pointerId = null;
            });

            container.addEventListener('pointercancel', () => {
                isDragging = false;
                pointerId = null;
            });

            container.addEventListener('pointermove', (e) => {
                if (!isDragging || e.pointerId !== pointerId) return;
                const deltaX = e.clientX - previousPointer.x;
                const deltaY = e.clientY - previousPointer.y;

                const vy = deltaX * dragSensitivity;
                const vx = deltaY * dragSensitivity;

                playerGroup.rotation.y += vy;
                playerGroup.rotation.x += vx;

                // Clamp X rotation a bit so it doesn't flip
                playerGroup.rotation.x = Math.max(-0.9, Math.min(0.6, playerGroup.rotation.x));

                rotVel.x = vx;
                rotVel.y = vy;
                previousPointer = { x: e.clientX, y: e.clientY };
            });

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            container.addEventListener('click', (event) => {
                const rect = container.getBoundingClientRect();
                const currentWidth = rect.width;
                const currentHeight = rect.height;
                mouse.x = ((event.clientX - rect.left) / currentWidth) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / currentHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(playerGroup.children);
                for (let i = 0; i < intersects.length; i++) {
                    if (intersects[i].object.userData.isButton) pressButton(intersects[i].object);
                }
            });

            function pressButton(btn) {
                const targetY = btn.userData.originalY - 0.2;
                buttons.forEach(b => b.position.y = b.userData.originalY);
                btn.position.y = targetY;

                if (!tapeInserted) {
                    setStatus('NO TAPE テープなし', '#ff71ce');
                    return;
                }

                if (btn.userData.name === 'play') {
                    // Toggle play/pause when already playing
                    if (isPlaying && !audioEl.paused) {
                        pausePlayback();
                    } else {
                        playCurrent();
                    }
                } else if (btn.userData.name === 'stop') {
                    stopPlayback();
                } else if (btn.userData.name === 'rewind') {
                    setStatus('巻き戻し <<', '#01cdfe');
                    prevTrack();
                } else {
                    setStatus('早送り >>', '#b967ff');
                    nextTrack();
                }
            }

            document.getElementById('insert-tape-btn').addEventListener('click', () => {
                if (tapeInserted) return;

                let pos = tapeGroup.position.x;
                const insertAnim = setInterval(() => {
                    pos -= 0.15;
                    tapeGroup.position.x = pos;

                    if (pos <= 0) {
                        clearInterval(insertAnim);
                        tapeGroup.position.set(0, 0.25, 0);
                        tapeInserted = true;
                        loadTrack(0);
                        setStatus('ロード完了 LOADED', '#01cdfe');
                    }
                }, 16);
            });

            // Start/stop loop based on visibility
            playerUpdateRunning();

            window.addEventListener('resize', () => {
                width = container.clientWidth;
                height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
                resizeVisualizerCanvas();
            });
        })();
    </script>
</body>

</html>