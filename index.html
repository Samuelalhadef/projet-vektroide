<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="VEKTROID - Immersive vaporwave experience featuring Floral Shoppe aesthetics with interactive 3D visuals">
    <meta name="theme-color" content="#1a0a2e">
    <title>VEKTROID // „Éï„É≠„Éº„É©„É´„ÅÆÂ∞ÇÈñÄÂ∫ó</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=VT323&family=Orbitron:wght@400;700;900&family=Noto+Sans+JP:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --vapor-pink: #ff71ce;
            --vapor-cyan: #01cdfe;
            --vapor-purple: #b967ff;
            --vapor-blue: #05ffa1;
            --vapor-yellow: #fffb96;
            --vapor-dark: #1a0a2e;
            --vapor-darker: #0d0221;
        }

        * {
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            margin: 0;
            background: var(--vapor-darker);
            color: white;
            font-family: 'VT323', monospace;
            overflow-x: hidden;
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32" shape-rendering="crispEdges"><path d="M4 2 L4 22 L8 18 L10 26 L14 24 L12 16 L18 16 Z" fill="%23ffffff" stroke="%23000000" stroke-width="2"/><path d="M6 6 L6 18 L9 15 L11 22 L12 21 L10 14 L15 14 Z" fill="%23cfcfcf"/></svg>') 0 0, auto;
        }

        /* ============================================
           VAPORWAVE OVERLAY EFFECTS
           ============================================ */

        /* CRT Scanlines */
        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background:
                repeating-linear-gradient(0deg,
                    rgba(0, 0, 0, 0.15),
                    rgba(0, 0, 0, 0.15) 1px,
                    transparent 1px,
                    transparent 2px);
            pointer-events: none;
            z-index: 9998;
        }

        /* VHS Tracking Effect */
        .vhs-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9997;
            background: linear-gradient(180deg,
                    transparent 0%,
                    rgba(255, 113, 206, 0.03) 50%,
                    transparent 100%);
            animation: vhsScroll 8s linear infinite;
        }

        @keyframes vhsScroll {
            0% {
                transform: translateY(-100%);
            }

            100% {
                transform: translateY(100%);
            }
        }

        /* Chromatic Aberration */
        .chromatic-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9996;
            mix-blend-mode: screen;
            opacity: 0.3;
        }

        /* Vignette */
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9995;
            box-shadow: inset 0 0 150px rgba(0, 0, 0, 0.9);
        }

        /* ============================================
           ANIMATED STARS BACKGROUND
           ============================================ */
        .stars-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
        }

        @keyframes twinkle {

            0%,
            100% {
                opacity: 0.3;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        /* ============================================
           VAPORWAVE NAVBAR
           ============================================ */
        /* Windows XP Navbar */
        .xp-navbar {
            position: fixed;
            top: 0;
            width: 100%;
            height: 68px;
            background: linear-gradient(180deg, #245DDA 0%, #1F52C6 10%, #1941A5 100%);
            border-bottom: 2px solid #00368a;
            display: flex;
            align-items: center;
            padding: 0 5px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .start-btn {
            height: 100%;
            background: linear-gradient(180deg, #3EAE36 0%, #37952F 100%);
            border-radius: 0 15px 15px 0;
            padding: 0 15px 0 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            font-family: Tahoma, sans-serif;
            font-weight: bold;
            font-style: italic;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            box-shadow: inset 2px 2px 5px rgba(255, 255, 255, 0.3);
            margin-left: -5px;
            user-select: none;
        }

        .xp-nav-links {
            margin-left: 16px;
            font-family: Tahoma, sans-serif;
            font-size: 16px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .xp-nav-links a {
            color: rgba(255, 255, 255, 0.95);
            text-decoration: none;
        }

        .xp-nav-links a:hover {
            text-decoration: underline;
        }

        /* ============================================
           FLOATING DECORATIVE ELEMENTS
           ============================================ */
        .floating-element {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            opacity: 0.6;
            animation: floatAround 20s ease-in-out infinite;
        }

        .floating-palm {
            font-size: 4rem;
            filter: drop-shadow(0 0 20px var(--vapor-cyan));
        }

        .floating-statue {
            font-size: 3rem;
            filter: drop-shadow(0 0 15px var(--vapor-pink));
        }

        @keyframes floatAround {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
            }

            25% {
                transform: translateY(-20px) rotate(5deg);
            }

            50% {
                transform: translateY(0) rotate(0deg);
            }

            75% {
                transform: translateY(20px) rotate(-5deg);
            }
        }

        /* ============================================
           SECTIONS
           ============================================ */
        section {
            position: relative;
            width: 100%;
            min-height: 100vh;
            overflow: hidden;
        }

        /* ============================================
           HERO SECTION
           ============================================ */
        #hero {
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(180deg,
                    var(--vapor-darker) 0%,
                    #16082c 30%,
                    #2d1b4e 60%,
                    #1a0a2e 100%);
        }

        /* Foreground shadow to fade forward wireframes into black */
        .hero-front-shadow {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 40vh;
            z-index: 2;
            pointer-events: none;
            background: linear-gradient(180deg,
                    rgba(0, 0, 0, 0) 0%,
                    rgba(0, 0, 0, 0.35) 45%,
                    rgba(0, 0, 0, 0.85) 100%);
        }

        /* Retro Sun */
        .retro-sun-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            overflow: hidden;
        }

        .retro-sun {
            width: 500px;
            height: 500px;
            border-radius: 50%;
            background: linear-gradient(to top,
                    #ff00ff 0%,
                    #ff6b6b 30%,
                    #feca57 60%,
                    #ff9ff3 100%);
            position: relative;
            margin-top: -50px;
            box-shadow:
                0 0 60px #ff00ff,
                0 0 120px rgba(255, 107, 107, 0.5),
                0 0 200px rgba(254, 202, 87, 0.3);
            animation: sunPulse 4s ease-in-out infinite;

            /* Horizontal Lines */
            -webkit-mask-image: linear-gradient(to top,
                    transparent 0%, black 0%,
                    transparent 4%, black 4%,
                    transparent 8%, black 8%,
                    transparent 12%, black 12%,
                    transparent 17%, black 17%,
                    transparent 23%, black 23%,
                    transparent 30%, black 30%,
                    transparent 38%, black 38%,
                    transparent 48%, black 48%,
                    black 100%);
            mask-image: linear-gradient(to top,
                    transparent 0%, black 0%,
                    transparent 4%, black 4%,
                    transparent 8%, black 8%,
                    transparent 12%, black 12%,
                    transparent 17%, black 17%,
                    transparent 23%, black 23%,
                    transparent 30%, black 30%,
                    transparent 38%, black 38%,
                    transparent 48%, black 48%,
                    black 100%);
        }

        @keyframes sunPulse {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.1);
            }
        }

        #hero-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Hero masked layer (hero model + pillars) */
        #hero-model-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #hero-model-reveal {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* hidden by default */
            clip-path: inset(100% 0px 0px 0px);
            filter: drop-shadow(0 0 24px rgba(1, 205, 254, 0.14)) drop-shadow(0 0 28px rgba(255, 113, 206, 0.12));
        }

        #hero-model-reveal::after {
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            top: -50%;
            bottom: -50%;
            opacity: 0;
            background:
                repeating-linear-gradient(0deg,
                    rgba(255, 255, 255, 0.07),
                    rgba(255, 255, 255, 0.07) 1px,
                    transparent 1px,
                    transparent 5px);
            mix-blend-mode: screen;
            transform: translateY(0);
        }

        #hero-model-reveal.is-revealing::after {
            opacity: 0.5;
            animation: heroModelScan 900ms linear infinite;
        }

        @keyframes heroModelScan {
            0% {
                transform: translateY(-15%);
            }

            100% {
                transform: translateY(15%);
            }
        }

        #hero-model-reveal canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Hero Content */
        .hero-content {
            z-index: 10;
            text-align: center;
            pointer-events: none;
            position: absolute;
            top: 35%;
            width: 100%;
            padding: 0 20px;
        }

        /* Glitch Text Effect */
        .glitch-container {
            position: relative;
            display: inline-block;
        }

        .glitch-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 6rem;
            font-weight: 900;
            position: relative;
            text-transform: uppercase;
            letter-spacing: 10px;
            background: linear-gradient(to bottom, #00ffff, #ff00cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 4px 4px 0px rgba(255, 0, 204, 0.5);
            animation: pulse 2s infinite;
        }

        .glitch-text::before,
        .glitch-text::after {
            content: none;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.3);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .japanese-title {
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 2.5rem;
            color: var(--vapor-pink);
            margin-top: 10px;
            text-shadow:
                0 0 10px var(--vapor-pink),
                0 0 20px var(--vapor-pink),
                0 0 40px var(--vapor-pink);
            letter-spacing: 15px;
            animation: neonFlicker 2s infinite;
        }

        @keyframes neonFlicker {

            0%,
            19%,
            21%,
            23%,
            25%,
            54%,
            56%,
            100% {
                opacity: 1;
                text-shadow:
                    0 0 10px var(--vapor-pink),
                    0 0 20px var(--vapor-pink),
                    0 0 40px var(--vapor-pink);
            }

            20%,
            24%,
            55% {
                opacity: 0.8;
                text-shadow: none;
            }
        }

        .subtitle {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            color: var(--vapor-cyan);
            letter-spacing: 8px;
            margin-top: 20px;
            text-shadow: 0 0 10px var(--vapor-cyan);
        }

        .scroll-indicator {
            font-size: 1rem;
            color: var(--vapor-purple);
            margin-top: 50px;
            animation: bounce 2s infinite;
            opacity: 0.7;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        /* Top fade to match hero bottom fade */
        .album-top-shadow {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            height: 35vh;
            z-index: 15;
            pointer-events: none;
            background: linear-gradient(180deg,
                    rgba(0, 0, 0, 0.95) 0%,
                    rgba(0, 0, 0, 0.5) 40%,
                    rgba(0, 0, 0, 0) 100%);
        }

        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            background: linear-gradient(90deg, var(--vapor-pink), var(--vapor-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
            margin-top: 80px;
            letter-spacing: 5px;
        }

        .section-subtitle {
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--vapor-purple);
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        /* ============================================
           RETRO PAINT INTERFACE
           ============================================ */
        .paint-window {
            background: #c0c0c0;
            border: 3px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            box-shadow:
                inset 1px 1px 0 #dfdfdf,
                inset -1px -1px 0 #0a0a0a,
                4px 4px 10px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 800px;
            margin: 20px auto;
        }

        .paint-titlebar {
            background: linear-gradient(90deg, #000080, #1084d0);
            color: white;
            padding: 4px 8px;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .paint-titlebar-buttons {
            display: flex;
            gap: 3px;
        }

        .paint-titlebar-btn {
            width: 18px;
            height: 18px;
            background: #c0c0c0;
            border: 2px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            font-size: 12px;
            line-height: 12px;
            text-align: center;
            cursor: pointer;
            font-family: 'VT323', monospace;
        }

        .paint-titlebar-btn:active {
            border-color: #808080 #ffffff #ffffff #808080;
        }

        .paint-menubar {
            background: #c0c0c0;
            padding: 2px 4px;
            font-family: 'VT323', monospace;
            font-size: 0.95rem;
            border-bottom: 1px solid #808080;
        }

        .paint-menubar span {
            padding: 2px 8px;
            cursor: pointer;
            color: #000;
        }

        .paint-menubar span:hover {
            background: #000080;
            color: white;
        }

        .paint-toolbar {
            background: #c0c0c0;
            padding: 4px;
            display: flex;
            gap: 8px;
            border-bottom: 1px solid #808080;
            flex-wrap: wrap;
        }

        .paint-tool-section {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .paint-tool-section-title {
            font-family: 'VT323', monospace;
            font-size: 0.8rem;
            color: #000;
            text-align: center;
        }

        .paint-color-palette {
            display: grid;
            grid-template-columns: repeat(14, 16px);
            gap: 1px;
            padding: 4px;
            background: #808080;
            border: 2px solid;
            border-color: #808080 #ffffff #ffffff #808080;
        }

        .paint-color {
            width: 16px;
            height: 16px;
            cursor: pointer;
            border: 1px solid #000;
        }

        .paint-color:hover {
            border: 2px solid #fff;
        }

        .paint-color.selected {
            border: 2px solid #ff0;
            box-shadow: 0 0 4px #ff0;
        }

        .paint-stickers-panel {
            display: flex;
            gap: 4px;
            padding: 4px;
            background: #808080;
            border: 2px solid;
            border-color: #808080 #ffffff #ffffff #808080;
            flex-wrap: wrap;
            max-width: 300px;
        }

        .paint-sticker {
            width: 40px;
            height: 40px;
            background: #c0c0c0;
            border: 2px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: transform 0.1s;
        }

        .paint-sticker:hover {
            transform: scale(1.1);
        }

        .paint-sticker:active,
        .paint-sticker.selected {
            border-color: #808080 #ffffff #ffffff #808080;
            background: #a0a0a0;
        }

        .paint-canvas-container {
            background: #808080;
            padding: 4px;
            margin: 4px;
            border: 2px solid;
            border-color: #808080 #ffffff #ffffff #808080;
            overflow: hidden;
            position: relative;
        }

        #paint-canvas {
            display: block;
            width: 100%;
            height: 400px;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .paint-statusbar {
            background: #c0c0c0;
            padding: 4px 8px;
            font-family: 'VT323', monospace;
            font-size: 0.85rem;
            color: #000;
            border-top: 2px solid;
            border-color: #808080 #ffffff #ffffff #808080;
            display: flex;
            justify-content: space-between;
        }

        /* Stickers on canvas */
        .canvas-sticker {
            position: absolute;
            font-size: 48px;
            cursor: move;
            user-select: none;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
            transition: transform 0.1s;
        }

        .canvas-sticker:hover {
            transform: scale(1.1);
        }

        .canvas-sticker.dragging {
            opacity: 0.8;
            transform: scale(1.2);
        }

        /* ============================================
           CASSETTE GENERATOR BUTTON & CASSETTE
           ============================================ */
        .paint-and-cassette-container {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            width: 100%;
            justify-content: center;
            padding: 20px;
        }

        .generate-cassette-btn {
            background: linear-gradient(180deg, #c0c0c0 0%, #a0a0a0 100%);
            border: 3px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            padding: 15px 20px;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            color: #000;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            transition: all 0.1s;
            min-width: 120px;
        }

        .generate-cassette-btn:hover {
            background: linear-gradient(180deg, #d0d0d0 0%, #b0b0b0 100%);
        }

        .generate-cassette-btn:active {
            border-color: #808080 #ffffff #ffffff #808080;
            transform: translateY(2px);
        }

        .generate-cassette-btn .btn-icon {
            font-size: 2.5rem;
        }

        .generate-cassette-btn .btn-text {
            text-align: center;
            line-height: 1.2;
        }

        /* Cassette Display Area - positioned on right side of Paint window */
        .cassette-display {
            position: absolute;
            right: -300px;
            top: 50%;
            transform: translateY(-50%);
            width: 300px;
            height: 200px;
            z-index: 50;
            overflow: visible;
        }

        .cassette-wrapper {
            position: absolute;
            left: -280px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Cassette Body */
        .cassette {
            width: 280px;
            height: 180px;
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 50%, #0a0a0a 100%);
            border-radius: 8px;
            position: relative;
            box-shadow:
                0 4px 20px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
            opacity: 0;
            visibility: hidden;
        }

        .cassette.printing {
            opacity: 1;
            visibility: visible;
        }

        .cassette.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Cassette Label (contains Paint design) */
        .cassette-label {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            height: 80px;
            background: #fff;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
        }

        .cassette-label canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Cassette Window (reels) */
        .cassette-window {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 180px;
            height: 50px;
            background: linear-gradient(180deg, #111 0%, #222 100%);
            border-radius: 25px;
            display: flex;
            align-items: center;
            justify-content: space-around;
            padding: 0 20px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .cassette-reel {
            width: 35px;
            height: 35px;
            background: conic-gradient(from 0deg, #444 0deg, #666 90deg, #444 180deg, #666 270deg, #444 360deg);
            border-radius: 50%;
            border: 3px solid #333;
            position: relative;
        }

        .cassette-reel::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: #222;
            border-radius: 50%;
        }

        .cassette.visible .cassette-reel {
            animation: reelSpin 2s linear infinite;
        }

        @keyframes reelSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Cassette Tape visible through window */
        .cassette-tape {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 2px;
            background: #8b4513;
        }

        /* Cassette screws */
        .cassette-screw {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle at 30% 30%, #888, #444);
            border-radius: 50%;
        }

        .cassette-screw:nth-child(1) { top: 8px; left: 8px; }
        .cassette-screw:nth-child(2) { top: 8px; right: 8px; }
        .cassette-screw:nth-child(3) { bottom: 8px; left: 8px; }
        .cassette-screw:nth-child(4) { bottom: 8px; right: 8px; }

        /* Generation Animation */
        @keyframes cassettePulse {
            0%, 100% { box-shadow: 0 0 20px var(--vapor-pink); }
            50% { box-shadow: 0 0 40px var(--vapor-cyan), 0 0 60px var(--vapor-pink); }
        }

        .cassette.generating {
            animation: cassettePulse 0.5s ease-in-out 3;
        }

        /* Sparkle effect during generation */
        .sparkle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, #fff 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            animation: sparkleAnim 0.6s ease-out forwards;
        }

        @keyframes sparkleAnim {
            0% {
                opacity: 1;
                transform: scale(0) translate(0, 0);
            }
            100% {
                opacity: 0;
                transform: scale(2) translate(var(--tx), var(--ty));
            }
        }

        /* ============================================
           MACHINE BUILDING SCREEN
           ============================================ */
        .machine-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #111;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            overflow: hidden;
        }

        .machine-screen.shake {
            animation: machineShake 0.1s infinite;
        }

        @keyframes machineShake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-3px, 2px); }
            50% { transform: translate(3px, -2px); }
            75% { transform: translate(-2px, -3px); }
        }

        .machine-title {
            font-family: 'VT323', monospace;
            font-size: 2rem;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
            margin-bottom: 20px;
            animation: machineTextFlicker 0.3s infinite;
        }

        @keyframes machineTextFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            75% { opacity: 0.95; }
        }

        .machine-progress {
            width: 80%;
            height: 30px;
            background: #222;
            border: 3px solid #444;
            position: relative;
            overflow: hidden;
        }

        .machine-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #0a0);
            width: 0%;
            transition: width 0.1s;
            box-shadow: 0 0 20px #0f0;
        }

        .machine-progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'VT323', monospace;
            color: #fff;
            font-size: 1rem;
            text-shadow: 1px 1px 0 #000;
        }

        .machine-gears {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .machine-gear {
            width: 40px;
            height: 40px;
            border: 4px solid #666;
            border-radius: 50%;
            position: relative;
            animation: gearSpin 1s linear infinite;
        }

        .machine-gear::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 15px;
            height: 15px;
            background: #444;
            border-radius: 50%;
        }

        .machine-gear:nth-child(2) {
            animation-direction: reverse;
            animation-duration: 0.8s;
        }

        .machine-gear:nth-child(3) {
            animation-duration: 1.2s;
        }

        @keyframes gearSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Pixel Smoke */
        .smoke-container {
            position: absolute;
            top: -50px;
            left: 0;
            width: 100%;
            height: 60px;
            overflow: visible;
            pointer-events: none;
        }

        .smoke-pixel {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #888;
            animation: smokeRise 2s ease-out forwards;
            image-rendering: pixelated;
        }

        @keyframes smokeRise {
            0% {
                opacity: 0.8;
                transform: translateY(0) scale(1);
            }
            50% {
                opacity: 0.5;
            }
            100% {
                opacity: 0;
                transform: translateY(-80px) translateX(var(--drift)) scale(2);
            }
        }

        /* Cassette Printer Animation - shake effect */
        .cassette.printing {
            animation: cassetteShake 0.1s infinite;
        }

        @keyframes cassetteShake {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(2px); }
        }

        /* Output slot on the right side of Paint window */
        .cassette-output-slot {
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 200px;
            background: linear-gradient(90deg, #2a2a2a, #1a1a1a);
            border: 3px solid #444;
            border-left: 3px solid #666;
            border-radius: 0 10px 10px 0;
            box-shadow:
                inset -8px 0 15px rgba(0,0,0,0.7),
                2px 0 10px rgba(0,0,0,0.5);
            z-index: 60;
        }

        .cassette-output-slot::before {
            content: '';
            position: absolute;
            left: 0;
            top: 15px;
            bottom: 15px;
            width: 6px;
            background: linear-gradient(180deg, #111 0%, #222 50%, #111 100%);
            border-radius: 3px;
        }

        .cassette-output-slot::after {
            content: '‚ñ∂';
            position: absolute;
            right: 2px;
            top: 50%;
            transform: translateY(-50%);
            color: #0f0;
            font-size: 10px;
            text-shadow: 0 0 5px #0f0;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .paint-window.printing .cassette-output-slot::after {
            opacity: 1;
            animation: slotBlink 0.5s infinite;
        }

        @keyframes slotBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* ============================================
           PLAYER SECTION
           ============================================ */
        #player-section {
            background: linear-gradient(180deg,
                    var(--vapor-darker) 0%,
                    #0a0015 50%,
                    #000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #player-canvas {
            width: 100%;
            height: 70vh;
            cursor: move;
            position: relative;
            z-index: 3;
        }

        .ui-overlay {
            position: absolute;
            bottom: 50px;
            display: flex;
            gap: 20px;
            z-index: 20;
        }

        .retro-btn {
            background: rgba(0, 0, 0, 0.8);
            color: var(--vapor-cyan);
            border: 2px solid var(--vapor-cyan);
            padding: 15px 30px;
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow:
                0 0 10px var(--vapor-cyan),
                inset 0 0 10px rgba(1, 205, 254, 0.2);
            transition: all 0.3s ease;
            letter-spacing: 2px;
        }

        .retro-btn:hover {
            background: var(--vapor-cyan);
            color: var(--vapor-darker);
            box-shadow:
                0 0 20px var(--vapor-cyan),
                0 0 40px var(--vapor-cyan);
        }

        #status-display {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--vapor-pink);
            padding: 15px 20px;
            color: var(--vapor-pink);
            font-family: 'VT323', monospace;
            font-size: 1.3rem;
            min-width: 200px;
            text-align: center;
            box-shadow: 0 0 10px rgba(255, 113, 206, 0.3);
        }

        /* Audio Visualizer */
        #audio-visualizer {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            /* Visible by default as a background layer (like the hero sun) */
            opacity: 0.35;
            transition: opacity 220ms ease;
            mix-blend-mode: screen;
            filter: blur(0.2px) saturate(1.25);
        }

        #audio-visualizer.is-active {
            opacity: 0.85;
        }

        /* ============================================
           FOOTER
           ============================================ */
        .vapor-footer {
            background: var(--vapor-darker);
            border-top: 1px solid var(--vapor-purple);
            padding: 40px 20px;
            text-align: center;
        }

        .footer-text {
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--vapor-purple);
            font-size: 1rem;
            opacity: 0.7;
        }

        .footer-jp {
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--vapor-pink);
            font-size: 1.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px var(--vapor-pink);
        }

        /* ============================================
           RESPONSIVE
           ============================================ */
        @media (max-width: 768px) {
            .glitch-text {
                font-size: 3rem;
                letter-spacing: 5px;
            }

            .japanese-title {
                font-size: 1.5rem;
                letter-spacing: 8px;
            }

            .subtitle {
                font-size: 1rem;
                letter-spacing: 4px;
            }

            .retro-sun {
                width: 300px;
                height: 300px;
            }

            .vapor-navbar {
                padding: 0 15px;
            }

            .nav-links {
                gap: 15px;
            }

            .nav-links a {
                font-size: 0.7rem;
            }

            .nav-jp {
                display: none;
            }

            .section-title {
                font-size: 1.8rem;
            }

            .ui-overlay {
                flex-direction: column;
                gap: 10px;
            }

            .floating-element {
                display: none;
            }
        }

        /* Reduced Motion */
        @media (prefers-reduced-motion: reduce) {

            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
            }

            html {
                scroll-behavior: auto;
            }
        }

        /* Focus states */
        a:focus,
        button:focus {
            outline: 2px solid var(--vapor-cyan);
            outline-offset: 3px;
        }

        /* ============================================
           TV COLOR BARS TRANSITION SECTION
           ============================================ */
        #tv-transition-wrapper {
            position: relative;
            height: 300vh; /* Extra height for scroll animation */
        }

        #tv-static-section {
            position: sticky;
            top: 0;
            height: 100vh;
            width: 100%;
            overflow: hidden;
            background: #000;
            z-index: 10;
        }

        .tv-color-bars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
        }

        .tv-color-bar {
            flex: 1;
            height: 100%;
        }

        .tv-color-bar:nth-child(1) { background: #ffffff; }
        .tv-color-bar:nth-child(2) { background: #ffff00; }
        .tv-color-bar:nth-child(3) { background: #00ffff; }
        .tv-color-bar:nth-child(4) { background: #00ff00; }
        .tv-color-bar:nth-child(5) { background: #ff00ff; }
        .tv-color-bar:nth-child(6) { background: #ff0000; }
        .tv-color-bar:nth-child(7) { background: #0000ff; }
        .tv-color-bar:nth-child(8) { background: #000000; }

        .tv-static-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.15) 0px,
                    rgba(0, 0, 0, 0.15) 2px,
                    transparent 2px,
                    transparent 4px
                );
            pointer-events: none;
            z-index: 2;
        }

        .tv-static-vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 200px rgba(0, 0, 0, 0.7);
            pointer-events: none;
            z-index: 3;
        }

        .tv-static-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'VT323', monospace;
            font-size: 3rem;
            color: white;
            text-shadow:
                3px 3px 0 #000,
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000;
            z-index: 4;
            opacity: 0.9;
        }

        /* Album sliding from right */
        #album-slide-container {
            position: absolute;
            top: 0;
            left: 100%;
            width: 100vw;
            height: 100vh;
            z-index: 5;
            will-change: transform;
        }

        /* ============================================
           ALBUM SECTION (inside slide container)
           ============================================ */
        #album-section {
            background: linear-gradient(180deg,
                    var(--vapor-dark) 0%,
                    #0f0520 50%,
                    var(--vapor-darker) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <!-- Overlay Effects -->
    <div class="crt-overlay"></div>
    <div class="vhs-overlay"></div>
    <div class="vignette"></div>

    <!-- Animated Stars -->
    <div class="stars-container" id="stars"></div>

    <!-- Navbar -->
    <nav class="xp-navbar" role="navigation" aria-label="Main navigation">
        <div class="start-btn" aria-label="Start">
            <div class="w-4 h-4 bg-white relative overflow-hidden mr-2 border border-blue-800 shadow-sm">
                <div class="absolute top-0 left-0 w-1/2 h-1/2 bg-[#F35325]"></div>
                <div class="absolute top-0 right-0 w-1/2 h-1/2 bg-[#81BC06]"></div>
                <div class="absolute bottom-0 left-0 w-1/2 h-1/2 bg-[#05A6F0]"></div>
                <div class="absolute bottom-0 right-0 w-1/2 h-1/2 bg-[#FFBA08]"></div>
            </div>
            <span>start</span>
        </div>
        <div class="xp-nav-links">
            <a href="#hero">System</a>
            <a href="#album-section">Artifacts</a>
            <a href="#player-section">Hardware</a>
        </div>
    </nav>

    <!-- Hero Section -->
    <section id="hero">
        <div class="retro-sun-container">
            <div class="retro-sun"></div>
        </div>
        <div id="hero-canvas"></div>
        <div id="hero-model-layer" aria-hidden="true">
            <div id="hero-model-reveal"></div>
        </div>
        <div class="hero-front-shadow" aria-hidden="true"></div>
        <div class="hero-content">
            <div class="glitch-container">
                <h1 class="glitch-text">VEKTROID</h1>
            </div>
            <p class="japanese-title">„Éï„É≠„Éº„É©„É´„ÅÆÂ∞ÇÈñÄÂ∫ó</p>
            <p class="subtitle">FLORAL SHOPPE // MACINTOSH PLUS</p>
            <p class="scroll-indicator">‚ñº „Çπ„ÇØ„É≠„Éº„É´„Åó„Å¶ÂàùÊúüÂåñ ‚ñº</p>
        </div>
    </section>

    <!-- TV Transition Wrapper (for sticky scroll effect) -->
    <div id="tv-transition-wrapper">
        <!-- TV Color Bars Section -->
        <section id="tv-static-section">
            <div class="tv-color-bars">
                <div class="tv-color-bar"></div>
                <div class="tv-color-bar"></div>
                <div class="tv-color-bar"></div>
                <div class="tv-color-bar"></div>
                <div class="tv-color-bar"></div>
                <div class="tv-color-bar"></div>
                <div class="tv-color-bar"></div>
                <div class="tv-color-bar"></div>
            </div>
            <div class="tv-static-overlay"></div>
            <div class="tv-static-vignette"></div>
            <div class="tv-static-text">NO SIGNAL ‰ø°Âè∑„Å™„Åó</div>

            <!-- Album slides in from the right -->
            <div id="album-slide-container">
                <section id="album-section">
                    <div class="paint-and-cassette-container">
                        <!-- Paint Window Interface -->
                        <div class="paint-window">
                            <div class="paint-titlebar">
                                <span>üé® untitled - Paint „Éö„Ç§„É≥„Éà</span>
                                <div class="paint-titlebar-buttons">
                                    <div class="paint-titlebar-btn">_</div>
                                    <div class="paint-titlebar-btn">‚ñ°</div>
                                    <div class="paint-titlebar-btn">‚úï</div>
                                </div>
                            </div>
                            <div class="paint-menubar">
                                <span><u>F</u>ile „Éï„Ç°„Ç§„É´</span>
                                <span><u>E</u>dit Á∑®ÈõÜ</span>
                                <span><u>V</u>iew Ë°®Á§∫</span>
                                <span><u>I</u>mage ÁîªÂÉè</span>
                                <span><u>C</u>olors Ëâ≤</span>
                                <span><u>H</u>elp „Éò„É´„Éó</span>
                            </div>
                            <div class="paint-toolbar">
                                <div class="paint-tool-section">
                                    <div class="paint-tool-section-title">ËÉåÊôØËâ≤ BG</div>
                                    <div class="paint-color-palette" id="color-palette">
                                        <!-- Colors will be added by JS -->
                                    </div>
                                </div>
                                <div class="paint-tool-section">
                                    <div class="paint-tool-section-title">„Çπ„ÉÜ„ÉÉ„Ç´„Éº STICKERS</div>
                                    <div class="paint-stickers-panel" id="stickers-panel">
                                        <!-- Stickers will be added by JS -->
                                    </div>
                                </div>
                                <!-- Generate Cassette Button in toolbar -->
                                <button class="generate-cassette-btn" id="generate-cassette-btn">
                                    <span class="btn-icon">üìº</span>
                                    <span class="btn-text">CREATE<br>„Ç´„Çª„ÉÉ„ÉàÁîüÊàê</span>
                                </button>
                            </div>
                            <div class="paint-canvas-container">
                                <canvas id="paint-canvas"></canvas>
                                <div id="stickers-layer"></div>
                            </div>
                            <div class="paint-statusbar">
                                <span id="paint-status">Ready Ê∫ñÂÇôÂÆå‰∫Ü</span>
                                <span id="paint-coords">0, 0</span>
                            </div>

                            <!-- Cassette output slot on right side of Paint window -->
                            <div class="cassette-output-slot"></div>

                            <!-- Cassette Display Area - comes out from right side -->
                            <div class="cassette-display" id="cassette-display">
                                <div class="cassette-wrapper">
                                    <div class="cassette" id="generated-cassette">
                                        <div class="cassette-screw"></div>
                                        <div class="cassette-screw"></div>
                                        <div class="cassette-screw"></div>
                                        <div class="cassette-screw"></div>
                                        <div class="cassette-label" id="cassette-label">
                                            <!-- Paint design will be copied here -->
                                        </div>
                                        <div class="cassette-window">
                                            <div class="cassette-reel"></div>
                                            <div class="cassette-tape"></div>
                                            <div class="cassette-reel"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </section>
    </div>

    <!-- Player Section -->
    <section id="player-section">
        <div class="absolute top-24 text-center z-10 pointer-events-none px-4">
            <h2 class="section-title">HARDWARE_„Éè„Éº„Éâ„Ç¶„Çß„Ç¢</h2>
            <p class="section-subtitle">„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ÂõûËª¢ // „Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Êìç‰Ωú</p>
        </div>
        <div id="player-canvas"></div>
        <canvas id="audio-visualizer" aria-hidden="true"></canvas>
        <div class="ui-overlay">
            <button class="retro-btn" id="insert-tape-btn">„ÉÜ„Éº„Éó„ÇíÊåøÂÖ•</button>
            <div id="status-display">NO TAPE „ÉÜ„Éº„Éó„Å™„Åó</div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="vapor-footer">
        <p class="footer-jp">ÁßÅ„ÅØ„ÅÇ„Å™„Åü„Å´‰ºö„ÅÑ„Åü„ÅÑ„Åß„Åô</p>
        <p class="footer-text">¬© 2024 VEKTROID // ALL RIGHTS RESERVED // ÂÖ®Ëëó‰ΩúÊ®©ÊâÄÊúâ</p>
    </footer>

    <script>
        /* ============================================
           GENERATE ANIMATED STARS
           ============================================ */
        (function () {
            const starsContainer = document.getElementById('stars');
            const numStars = 150;

            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = Math.random() * 3 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.animationDelay = Math.random() * 3 + 's';
                star.style.animationDuration = (Math.random() * 2 + 2) + 's';
                starsContainer.appendChild(star);
            }
        })();

        /* ============================================
           TV COLOR BARS + HORIZONTAL ALBUM SCROLL
           ============================================ */
        (function () {
            const wrapper = document.getElementById('tv-transition-wrapper');
            const albumSlideContainer = document.getElementById('album-slide-container');

            function updateAlbumPosition() {
                if (!wrapper || !albumSlideContainer) return;

                const wrapperRect = wrapper.getBoundingClientRect();
                const wrapperTop = wrapperRect.top;
                const wrapperHeight = wrapper.offsetHeight;
                const viewportHeight = window.innerHeight;

                // Calculate scroll progress within the wrapper
                // 0 = just entered, 1 = fully scrolled through
                let progress = 0;

                if (wrapperTop <= 0) {
                    // How far we've scrolled into the wrapper
                    const scrolledIntoWrapper = Math.abs(wrapperTop);
                    // Total scrollable distance (wrapper height minus one viewport)
                    const totalScrollDistance = wrapperHeight - viewportHeight;

                    if (totalScrollDistance > 0) {
                        progress = Math.min(1, Math.max(0, scrolledIntoWrapper / totalScrollDistance));
                    }
                }

                // Album slides from right (100%) to left (0%)
                // Start sliding after 30% scroll progress, finish at 100%
                let slideProgress = 0;
                if (progress > 0.3) {
                    slideProgress = (progress - 0.3) / 0.7; // Normalize to 0-1
                    slideProgress = Math.min(1, slideProgress);
                }

                // Ease out cubic for smooth deceleration
                const eased = 1 - Math.pow(1 - slideProgress, 3);

                // Translate from 100% (off-screen right) to -100% (covers the color bars)
                const translateX = 100 - (eased * 200);

                albumSlideContainer.style.transform = `translateX(${translateX}%)`;
            }

            // Use requestAnimationFrame for smooth scrolling
            let ticking = false;

            window.addEventListener('scroll', () => {
                if (!ticking) {
                    requestAnimationFrame(() => {
                        updateAlbumPosition();
                        ticking = false;
                    });
                    ticking = true;
                }
            });

            // Initial position
            updateAlbumPosition();

            // Handle resize
            window.addEventListener('resize', updateAlbumPosition);
        })();

        /* ============================================
           SCENE 1: HERO - VAPORWAVE GRID TERRAIN
           ============================================ */
        (function () {
            const container = document.getElementById('hero-canvas');
            const heroSection = document.getElementById('hero');
            const modelRevealEl = document.getElementById('hero-model-reveal');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x1a0a2e, 0.015);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 300);
            camera.position.set(0, 2, 7.5);
            camera.lookAt(0, 0.2, -18);
            camera.layers.set(0);

            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            // Separate renderer/camera layers for masked content (hero model + pillars)
            const modelCamera = new THREE.PerspectiveCamera(camera.fov, 1, camera.near, camera.far);
            modelCamera.position.copy(camera.position);
            modelCamera.quaternion.copy(camera.quaternion);
            modelCamera.layers.set(1);

            // Pillars get the same clip/scanline mask, but should NOT follow the hero model orbit.
            // Render them with a fixed camera into the same masked container.
            const pillarsCamera = new THREE.PerspectiveCamera(camera.fov, 1, camera.near, camera.far);
            pillarsCamera.position.copy(camera.position);
            pillarsCamera.quaternion.copy(camera.quaternion);
            pillarsCamera.layers.set(2);

            const pillarsRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            pillarsRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            pillarsRenderer.outputEncoding = THREE.sRGBEncoding;

            const modelRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            modelRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            modelRenderer.outputEncoding = THREE.sRGBEncoding;
            if (modelRevealEl) {
                // Append pillars first so the hero model renders on top.
                modelRevealEl.appendChild(pillarsRenderer.domElement);
                modelRevealEl.appendChild(modelRenderer.domElement);
            }

            function resizeModelRenderer() {
                if (!modelRevealEl) return;
                const w = Math.max(1, modelRevealEl.clientWidth);
                const h = Math.max(1, modelRevealEl.clientHeight);
                modelCamera.aspect = w / h;
                modelCamera.updateProjectionMatrix();
                pillarsCamera.aspect = w / h;
                pillarsCamera.updateProjectionMatrix();
                modelRenderer.setSize(w, h);
                pillarsRenderer.setSize(w, h);
            }
            resizeModelRenderer();

            // Lights for the GLB model
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x140021, 0.8);
            hemiLight.position.set(0, 5, 0);
            hemiLight.layers.set(1);
            hemiLight.layers.enable(2);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
            dirLight.position.set(4, 6, 3);
            dirLight.layers.set(1);
            dirLight.layers.enable(2);
            scene.add(dirLight);

            // Marble pillars loaded from GLB (masked like hero model, but rendered with fixed camera)
            const pillarsRoot = new THREE.Group();
            pillarsRoot.layers.set(2);
            scene.add(pillarsRoot);

            const leftPillar = new THREE.Group();
            const rightPillar = new THREE.Group();
            leftPillar.layers.set(2);
            rightPillar.layers.set(2);
            pillarsRoot.add(leftPillar);
            pillarsRoot.add(rightPillar);

            // Lower them so they sit in the scene (closer to the wireframe plane at y=-5)
            const pillarsBaseY = -5.0;
            const pillarsZ = -12;
            const pillarsSideOffset = 6.2 * 3; // ~3x more off to the sides
            leftPillar.position.set(-pillarsSideOffset, pillarsBaseY, pillarsZ);
            rightPillar.position.set(pillarsSideOffset, pillarsBaseY, pillarsZ);

            // Mirror slight twist so they don't look perfectly identical
            leftPillar.rotation.y = 0.3;
            rightPillar.rotation.y = -0.25;

            // Add a little light so marble reads against the background
            const pillarGlowLeft = new THREE.PointLight(0xff71ce, 1.25, 26);
            pillarGlowLeft.position.set(-pillarsSideOffset + 1.5, 1.5, -8);
            pillarGlowLeft.layers.set(2);
            pillarsRoot.add(pillarGlowLeft);
            const pillarGlowRight = new THREE.PointLight(0x01cdfe, 1.25, 26);
            pillarGlowRight.position.set(pillarsSideOffset - 1.5, 1.5, -8);
            pillarGlowRight.layers.set(2);
            pillarsRoot.add(pillarGlowRight);

            (function loadMarblePillars() {
                if (!THREE.GLTFLoader) {
                    console.warn('GLTFLoader not found. Ensure the GLTFLoader script is loaded.');
                    return;
                }

                const loader = new THREE.GLTFLoader();
                loader.load(
                    'source/marble_pillar.glb',
                    (gltf) => {
                        const pillarTemplate = gltf.scene;

                        // Make sure textures look correct under sRGB output.
                        pillarTemplate.traverse((obj) => {
                            obj.layers.set(2);
                            if (!obj.isMesh) return;
                            obj.castShadow = false;
                            obj.receiveShadow = false;
                            if (obj.material && obj.material.map) {
                                obj.material.map.encoding = THREE.sRGBEncoding;
                            }
                        });

                        // Scale to a consistent visual height so it matches the scene.
                        const targetHeight = 10.5;
                        const yStretch = 1.5; // elongate vertically a bit
                        const bbox = new THREE.Box3().setFromObject(pillarTemplate);
                        const size = new THREE.Vector3();
                        bbox.getSize(size);
                        const currentHeight = Math.max(0.001, size.y);
                        const s = targetHeight / currentHeight;

                        const leftInstance = pillarTemplate.clone(true);
                        const rightInstance = pillarTemplate.clone(true);

                        leftInstance.scale.set(s, s * yStretch, s);
                        rightInstance.scale.set(s, s * yStretch, s);

                        // Keep bases on the same y
                        const leftBox = new THREE.Box3().setFromObject(leftInstance);
                        const rightBox = new THREE.Box3().setFromObject(rightInstance);
                        const leftMin = leftBox.min.y;
                        const rightMin = rightBox.min.y;
                        leftInstance.position.y -= leftMin;
                        rightInstance.position.y -= rightMin;

                        leftPillar.add(leftInstance);
                        rightPillar.add(rightInstance);
                    },
                    undefined,
                    (err) => {
                        console.error('Failed to load marble pillar GLB:', err);
                    }
                );
            })();

            // Grid Terrain
            const tileDepth = 40;
            const tileWidth = 200;
            const segmentsW = 18;
            const segmentsD = 10;

            const geometry = new THREE.PlaneGeometry(tileWidth, tileDepth, segmentsW, segmentsD);
            const pos = geometry.attributes.position;

            // Use coefficient that ensures seamless tiling (2œÄ/tileDepth for perfect periodicity)
            const yCoef = (3 * Math.PI) / tileDepth;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);

                let z = 0;
                z += Math.sin(x * 0.08) * 1.5;
                z += Math.cos(x * 0.2 + y * yCoef) * 2;

                const dist = Math.abs(x) / (tileWidth / 2);
                z += Math.pow(dist, 2.5) * 50;

                pos.setZ(i, z);
            }
            geometry.computeVertexNormals();

            // Gradient wireframe material
            const tiles = [];
            const tileMats = [];
            for (let i = 0; i < 4; i++) {
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff71ce,
                    wireframe: true,
                    transparent: true,
                    opacity: 0
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(0, -5, -i * tileDepth);
                scene.add(mesh);
                tiles.push(mesh);
                tileMats.push(material);
            }

            // Load the hero GLB model.
            // Instead of offsetting the rotation axis (which can be fiddly depending on model origin/orientation),
            // we orbit the camera around the model based on scroll.
            const heroModelRoot = new THREE.Group();
            heroModelRoot.layers.set(1);
            heroModelRoot.visible = false;
            scene.add(heroModelRoot);
            let heroModel = null;
            const heroModelCenter = new THREE.Vector3();

            const heroOrbitCenter = new THREE.Vector3(0, -0.25, -2.5);
            let heroOrbitRadius = 7.8;
            let heroOrbitHeight = 1.9;
            let currentOrbitAngle = 0;

            (function loadHeroModel() {
                if (!THREE.GLTFLoader) {
                    console.warn('GLTFLoader not found. Ensure the GLTFLoader script is loaded.');
                    return;
                }

                const loader = new THREE.GLTFLoader();
                loader.load(
                    'source/vaporwave.glb',
                    (gltf) => {
                        heroModel = gltf.scene;

                        // Reasonable default transforms; adjust if your model is huge/tiny.
                        heroModel.scale.setScalar(2.5);

                        // Ensure materials look correct under sRGB output.
                        heroModel.traverse((obj) => {
                            if (!obj.isMesh) return;
                            obj.castShadow = false;
                            obj.receiveShadow = false;
                            if (obj.material && obj.material.map) {
                                obj.material.map.encoding = THREE.sRGBEncoding;
                            }
                            obj.layers.set(1);
                        });

                        // Center the pivot on the model (bounding box center), then move the rotation axis back ~100cm.
                        new THREE.Box3().setFromObject(heroModel).getCenter(heroModelCenter);
                        heroModel.position.sub(heroModelCenter);
                        heroModelRoot.position.copy(heroOrbitCenter);
                        heroModelRoot.add(heroModel);
                        heroModelRoot.visible = true;

                        // Reveal the model line-by-line (mask only covers the model canvas)
                        if (modelRevealEl) {
                            modelRevealEl.classList.add('is-revealing');

                            const durationMs = 1200;
                            const start = performance.now();
                            const stepPx = 6; // controls "line-by-line" feel

                            const tick = (now) => {
                                const t = Math.max(0, Math.min(1, (now - start) / durationMs));
                                const h = Math.max(1, modelRevealEl.clientHeight);
                                const revealed = Math.floor((h * t) / stepPx) * stepPx;
                                const topPx = Math.max(0, Math.round(h - revealed));
                                modelRevealEl.style.clipPath = `inset(${topPx}px 0px 0px 0px)`;

                                if (t < 1) {
                                    requestAnimationFrame(tick);
                                } else {
                                    modelRevealEl.style.clipPath = 'inset(0px 0px 0px 0px)';
                                    // fade scanlines out shortly after full reveal
                                    setTimeout(() => modelRevealEl.classList.remove('is-revealing'), 350);
                                }
                            };
                            requestAnimationFrame(tick);
                        }
                    },
                    undefined,
                    (err) => {
                        console.error('Failed to load hero GLB:', err);
                    }
                );
            })();

            let time = 0;

            function smoothstep(edge0, edge1, x) {
                const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
                return t * t * (3 - 2 * t);
            }

            function clamp01(x) {
                return Math.max(0, Math.min(1, x));
            }

            function getPageScrollProgress() {
                const doc = document.documentElement;
                const maxScroll = Math.max(1, doc.scrollHeight - window.innerHeight);
                return clamp01(window.scrollY / maxScroll);
            }

            // Pause hero rendering when off-screen / tab hidden (performance)
            let heroRaf = 0;
            let heroIsRunning = false;
            let heroInView = true;

            function heroLoop() {
                if (!heroIsRunning) return;
                heroRaf = requestAnimationFrame(heroLoop);

                time += 0.01;

                // Orbit ONLY the model camera so the wireframe terrain stays stable.
                // (Main camera remains fixed, keeping the background orientation consistent.)
                if (heroModelRoot && heroModelRoot.visible) {
                    const p = getPageScrollProgress();
                    // 2 full orbits across the full page.
                    const targetAngle = 3 * p * Math.PI * 4 + Math.PI / 2;
                    currentOrbitAngle += (targetAngle - currentOrbitAngle) * 0.12;

                    const x = heroOrbitCenter.x + Math.cos(currentOrbitAngle) * heroOrbitRadius;
                    const z = heroOrbitCenter.z + Math.sin(currentOrbitAngle) * heroOrbitRadius;

                    modelCamera.position.set(x, heroOrbitCenter.y + heroOrbitHeight, z);
                    modelCamera.lookAt(heroOrbitCenter.x, heroOrbitCenter.y, heroOrbitCenter.z);

                    // Subtle idle tilt on the model itself for depth.
                    if (heroModel) heroModel.rotation.x = -0.05 + Math.sin(time * 0.3) * 0.02;
                }

                const speed = 0.12;
                tiles.forEach(tile => {
                    tile.position.z += speed;
                    if (tile.position.z >= tileDepth) {
                        tile.position.z -= tileDepth * 4;
                    }
                });

                // Pillars: automatic spin + half-scroll parallax (semi-fixed feel)
                // Use hero section's top offset so effect is tied to the section while it's on screen.
                if (pillarsRoot && heroSection) {
                    // Auto spin
                    leftPillar.rotation.y += 0.007;
                    rightPillar.rotation.y -= 0.008;

                    const rectTopPx = heroSection.getBoundingClientRect().top;
                    const depth = Math.max(0.1, Math.abs(camera.position.z - pillarsZ));
                    const worldHeightAtDepth = 2 * depth * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5));
                    const worldPerPx = worldHeightAtDepth / Math.max(1, window.innerHeight);

                    // Compensate ~50% of scroll movement (correct direction)
                    const parallaxY = (rectTopPx) * 0.5 * worldPerPx;
                    pillarsRoot.position.y = parallaxY;
                }

                // Color cycling
                const hue = (Math.sin(time * 0.5) + 1) / 2;
                tileMats.forEach((mat, idx) => {
                    mat.color.setHSL(hue * 0.1 + 0.85, 1, 0.6);

                    // Distance-based fade: far tiles spawn fully transparent
                    const z = tiles[idx].position.z;
                    const farZ = -tileDepth * 3.0;   // most distant tile start
                    const nearZ = tileDepth * 0.35;  // closer region becomes opaque
                    const opacity = smoothstep(farZ, nearZ, z);
                    mat.opacity = opacity;
                });


                renderer.render(scene, camera);
                // Render masked pillars with a fixed camera (so they don't orbit with the hero model)
                pillarsCamera.position.copy(camera.position);
                pillarsCamera.quaternion.copy(camera.quaternion);
                pillarsRenderer.render(scene, pillarsCamera);
                modelRenderer.render(scene, modelCamera);
            }

            function heroStart() {
                if (heroIsRunning) return;
                heroIsRunning = true;
                heroRaf = requestAnimationFrame(heroLoop);
            }

            function heroStop() {
                heroIsRunning = false;
                if (heroRaf) cancelAnimationFrame(heroRaf);
                heroRaf = 0;
            }

            function heroUpdateRunning() {
                const shouldRun = heroInView && !document.hidden;
                if (shouldRun) heroStart();
                else heroStop();
            }

            if (heroSection) {
                const heroObserver = new IntersectionObserver(
                    (entries) => {
                        heroInView = entries.some(e => e.isIntersecting);
                        heroUpdateRunning();
                    },
                    { threshold: 0.05 }
                );
                heroObserver.observe(heroSection);
            }
            document.addEventListener('visibilitychange', heroUpdateRunning);
            heroUpdateRunning();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);

                modelCamera.fov = camera.fov;
                modelCamera.near = camera.near;
                modelCamera.far = camera.far;
                pillarsCamera.fov = camera.fov;
                pillarsCamera.near = camera.near;
                pillarsCamera.far = camera.far;
                resizeModelRenderer();
            });
        })();

        /* ============================================
           RETRO PAINT INTERFACE
           ============================================ */
        (function () {
            const canvas = document.getElementById('paint-canvas');
            const ctx = canvas.getContext('2d');
            const colorPalette = document.getElementById('color-palette');
            const stickersPanel = document.getElementById('stickers-panel');
            const stickersLayer = document.getElementById('stickers-layer');
            const statusEl = document.getElementById('paint-status');
            const coordsEl = document.getElementById('paint-coords');

            // Color palette - vaporwave + classic Paint colors
            const colors = [
                '#000000', '#808080', '#800000', '#808000', '#008000', '#008080', '#000080', '#800080',
                '#ffffff', '#c0c0c0', '#ff0000', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff',
                '#ff71ce', '#01cdfe', '#b967ff', '#05ffa1', '#fffb96', '#1a0a2e', '#ff6b6b', '#4ecdc4',
                '#ffe66d', '#95e1d3', '#f38181', '#aa96da'
            ];

            // Stickers list
            const stickers = [
                'üå¥', 'üóø', 'üå∏', 'üíé', 'üéµ', 'üíú', 'üåä', '‚òÄÔ∏è',
                'üèõÔ∏è', 'üå∫', 'üíø', 'üìº', 'üéß', '‚ú®', 'ü¶©', 'üçá'
            ];

            let currentBgColor = '#ff71ce'; // Pink vaporwave default (so turquoise text is visible)
            let selectedSticker = null;

            // Setup canvas size
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth - 8;
                canvas.height = 400;
                drawCanvas();
            }

            // Draw canvas with background and default text
            function drawCanvas() {
                // Background
                ctx.fillStyle = currentBgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Default Japanese text - Macintosh Plus Floral Shoppe
                // Text color: turquoise (#01cdfe) on dark backgrounds, dark on light backgrounds
                const textColor = isLightColor(currentBgColor) ? '#1a0a2e' : '#01cdfe';
                ctx.fillStyle = textColor;
                ctx.font = 'bold 48px "Noto Sans JP", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Add text shadow for better readability
                ctx.shadowColor = isLightColor(currentBgColor) ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                // „Éû„ÉÉ„Ç≠„É≥„Éà„ÉÉ„Ç∑„É•„Éª„Éó„É©„Çπ = Macintosh Plus
                // „Éï„É≠„Éº„É©„É´„ÅÆÂ∞ÇÈñÄÂ∫ó = Floral Shoppe
                ctx.fillText('„Éû„ÉÉ„Ç≠„É≥„Éà„ÉÉ„Ç∑„É•„Éª„Éó„É©„Çπ', canvas.width / 2, canvas.height / 2 - 30);
                ctx.fillText('„Éï„É≠„Éº„É©„É´„ÅÆÂ∞ÇÈñÄÂ∫ó', canvas.width / 2, canvas.height / 2 + 40);

                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            // Check if color is light (moved before drawCanvas uses it)
            function isLightColor(color) {
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                return brightness > 128;
            }

            // Create color palette
            colors.forEach((color, index) => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'paint-color';
                colorDiv.style.backgroundColor = color;
                if (color === currentBgColor) colorDiv.classList.add('selected');

                colorDiv.addEventListener('click', () => {
                    // Remove selected from all
                    document.querySelectorAll('.paint-color').forEach(c => c.classList.remove('selected'));
                    colorDiv.classList.add('selected');
                    currentBgColor = color;

                    // Redraw canvas with new background and text
                    drawCanvas();
                    statusEl.textContent = 'ËÉåÊôØËâ≤Â§âÊõ¥ Background changed';
                });

                colorPalette.appendChild(colorDiv);
            });

            // Create stickers panel
            stickers.forEach(sticker => {
                const stickerDiv = document.createElement('div');
                stickerDiv.className = 'paint-sticker';
                stickerDiv.textContent = sticker;

                stickerDiv.addEventListener('click', () => {
                    document.querySelectorAll('.paint-sticker').forEach(s => s.classList.remove('selected'));
                    stickerDiv.classList.add('selected');
                    selectedSticker = sticker;
                    statusEl.textContent = '„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÖçÁΩÆ Click to place: ' + sticker;
                    canvas.style.cursor = 'copy';
                });

                stickersPanel.appendChild(stickerDiv);
            });

            // Place sticker on canvas click
            canvas.addEventListener('click', (e) => {
                if (!selectedSticker) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const stickerEl = document.createElement('div');
                stickerEl.className = 'canvas-sticker';
                stickerEl.textContent = selectedSticker;
                stickerEl.style.left = x + 'px';
                stickerEl.style.top = y + 'px';

                // Make sticker draggable
                let isDragging = false;
                let offsetX, offsetY;

                stickerEl.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    stickerEl.classList.add('dragging');
                    offsetX = e.clientX - stickerEl.offsetLeft;
                    offsetY = e.clientY - stickerEl.offsetTop;
                    e.stopPropagation();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    stickerEl.style.left = (e.clientX - offsetX) + 'px';
                    stickerEl.style.top = (e.clientY - offsetY) + 'px';
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    stickerEl.classList.remove('dragging');
                });

                // Double click to remove
                stickerEl.addEventListener('dblclick', () => {
                    stickerEl.remove();
                    statusEl.textContent = '„Çπ„ÉÜ„ÉÉ„Ç´„ÉºÂâäÈô§ Sticker removed';
                });

                stickersLayer.appendChild(stickerEl);
                statusEl.textContent = '„Çπ„ÉÜ„ÉÉ„Ç´„ÉºÈÖçÁΩÆÂÆå‰∫Ü Sticker placed!';
            });

            // Track mouse position
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.round(e.clientX - rect.left);
                const y = Math.round(e.clientY - rect.top);
                coordsEl.textContent = x + ', ' + y;
            });

            // Initialize
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Make stickers layer match canvas position
            stickersLayer.style.position = 'absolute';
            stickersLayer.style.top = '0';
            stickersLayer.style.left = '0';
            stickersLayer.style.width = '100%';
            stickersLayer.style.height = '100%';
            stickersLayer.style.pointerEvents = 'none';

            // Enable pointer events only on stickers themselves
            const style = document.createElement('style');
            style.textContent = '.canvas-sticker { pointer-events: auto; }';
            document.head.appendChild(style);

            // ============================================
            // CASSETTE GENERATOR - INDUSTRIAL MACHINE
            // ============================================
            const generateBtn = document.getElementById('generate-cassette-btn');
            const cassette = document.getElementById('generated-cassette');
            const cassetteLabel = document.getElementById('cassette-label');
            const cassetteDisplay = document.getElementById('cassette-display');
            const paintCanvasContainer = document.querySelector('.paint-canvas-container');
            const paintWindow = document.querySelector('.paint-window');

            let smokeInterval = null;
            let isGenerating = false;

            // Create pixel smoke effect
            function createSmoke(container) {
                const smokeContainer = document.createElement('div');
                smokeContainer.className = 'smoke-container';
                container.appendChild(smokeContainer);

                smokeInterval = setInterval(() => {
                    for (let i = 0; i < 3; i++) {
                        const smoke = document.createElement('div');
                        smoke.className = 'smoke-pixel';
                        smoke.style.left = (Math.random() * 100) + '%';
                        smoke.style.bottom = '0';
                        smoke.style.setProperty('--drift', (Math.random() * 40 - 20) + 'px');
                        smoke.style.background = ['#666', '#888', '#aaa', '#555'][Math.floor(Math.random() * 4)];
                        smoke.style.width = (6 + Math.random() * 6) + 'px';
                        smoke.style.height = smoke.style.width;
                        smokeContainer.appendChild(smoke);
                        setTimeout(() => smoke.remove(), 2000);
                    }
                }, 150);

                return smokeContainer;
            }

            // Create machine screen overlay
            function showMachineScreen() {
                const machineScreen = document.createElement('div');
                machineScreen.className = 'machine-screen shake';
                machineScreen.innerHTML = `
                    <div class="machine-title">‚öôÔ∏è CASSETTE FACTORY „Ç´„Çª„ÉÉ„ÉàÂ∑•Â†¥ ‚öôÔ∏è</div>
                    <div class="machine-progress">
                        <div class="machine-progress-bar" id="machine-progress-bar"></div>
                        <div class="machine-progress-text" id="machine-progress-text">INITIALIZING... ÂàùÊúüÂåñ‰∏≠</div>
                    </div>
                    <div class="machine-gears">
                        <div class="machine-gear"></div>
                        <div class="machine-gear"></div>
                        <div class="machine-gear"></div>
                    </div>
                `;
                paintCanvasContainer.appendChild(machineScreen);
                return machineScreen;
            }

            // Animate progress bar with messages
            function animateProgress(progressBar, progressText, callback) {
                const messages = [
                    { pct: 0, text: 'LOADING DESIGN... „Éá„Ç∂„Ç§„É≥Ë™≠Ëæº‰∏≠' },
                    { pct: 20, text: 'MIXING COLORS... Ëâ≤„ÇíÊ∑∑Âêà‰∏≠' },
                    { pct: 40, text: 'HEATING PLASTIC... „Éó„É©„Çπ„ÉÅ„ÉÉ„ÇØÂä†ÁÜ±' },
                    { pct: 60, text: 'MOLDING CASSETTE... „Ç´„Çª„ÉÉ„ÉàÊàêÂΩ¢' },
                    { pct: 80, text: 'APPLYING LABEL... „É©„Éô„É´Ë≤º‰ªò' },
                    { pct: 95, text: 'FINISHING... ‰ªï‰∏ä„Åí‰∏≠' },
                    { pct: 100, text: 'COMPLETE! ÂÆåÊàê!' }
                ];

                let currentStep = 0;
                const interval = setInterval(() => {
                    if (currentStep >= messages.length) {
                        clearInterval(interval);
                        callback();
                        return;
                    }
                    const msg = messages[currentStep];
                    progressBar.style.width = msg.pct + '%';
                    progressText.textContent = msg.text;
                    currentStep++;
                }, 400);
            }

            // Capture Paint canvas with stickers
            function capturePaintDesign() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(canvas, 0, 0);

                const stickerElements = stickersLayer.querySelectorAll('.canvas-sticker');
                stickerElements.forEach(sticker => {
                    const x = parseInt(sticker.style.left) || 0;
                    const y = parseInt(sticker.style.top) || 0;
                    tempCtx.font = '48px serif';
                    tempCtx.fillText(sticker.textContent, x - 24, y + 16);
                });

                return tempCanvas;
            }

            // Printer animation - cassette comes out with jerky movements
            function printerAnimation(designCanvas) {
                const cassetteWrapper = document.querySelector('.cassette-wrapper');

                // Prepare the cassette label
                cassetteLabel.innerHTML = '';
                const labelCanvas = document.createElement('canvas');
                labelCanvas.width = 250;
                labelCanvas.height = 80;
                const labelCtx = labelCanvas.getContext('2d');
                labelCtx.drawImage(designCanvas, 0, 0, labelCanvas.width, labelCanvas.height);
                cassetteLabel.appendChild(labelCanvas);

                // Add printing class to paint window for slot LED
                paintWindow.classList.add('printing');

                // Start cassette hidden to the left (inside the machine)
                let currentX = -280;
                cassetteWrapper.style.left = currentX + 'px';
                cassette.classList.add('printing');
                cassette.classList.remove('visible');

                // Jerky printer movement parameters
                const targetX = 10;
                const totalDistance = targetX - currentX; // 290px
                const steps = 15;
                let step = 0;

                const printerSound = () => {
                    // Visual feedback - shake the paint window
                    paintWindow.style.transform = `translateX(${(Math.random() - 0.5) * 3}px)`;
                    setTimeout(() => {
                        paintWindow.style.transform = '';
                    }, 50);
                };

                const printerInterval = setInterval(() => {
                    if (step >= steps) {
                        clearInterval(printerInterval);
                        // Final position
                        cassetteWrapper.style.left = targetX + 'px';
                        cassette.classList.remove('printing');
                        cassette.classList.add('visible');
                        paintWindow.classList.remove('printing');
                        statusEl.textContent = '„Ç´„Çª„ÉÉ„ÉàÂÆåÊàê! Cassette created!';
                        generateBtn.disabled = false;
                        generateBtn.style.opacity = '1';
                        isGenerating = false;
                        return;
                    }

                    // Calculate position with easing and jerk
                    const progress = (step + 1) / steps;
                    const eased = 1 - Math.pow(1 - progress, 3); // ease out cubic
                    const jerk = (Math.random() - 0.5) * 6;
                    currentX = -280 + (eased * totalDistance) + jerk;

                    cassetteWrapper.style.left = currentX + 'px';
                    printerSound();
                    step++;
                }, 150 + Math.random() * 100); // Variable timing for old printer effect
            }

            generateBtn.addEventListener('click', () => {
                if (isGenerating) return;
                isGenerating = true;

                // Update status
                statusEl.textContent = '„Ç´„Çª„ÉÉ„ÉàÁîüÊàê‰∏≠... Generating cassette...';

                // Disable button
                generateBtn.disabled = true;
                generateBtn.style.opacity = '0.6';

                // Hide existing cassette and reset position
                const cassetteWrapper = document.querySelector('.cassette-wrapper');
                cassette.classList.remove('visible', 'printing');
                cassetteWrapper.style.left = '-280px';

                // Capture design BEFORE showing machine screen
                const designCanvas = capturePaintDesign();

                // Show machine screen
                const machineScreen = showMachineScreen();

                // Add smoke effect
                const smokeContainer = createSmoke(paintWindow);

                // Get progress elements
                const progressBar = document.getElementById('machine-progress-bar');
                const progressText = document.getElementById('machine-progress-text');

                // Animate progress
                setTimeout(() => {
                    animateProgress(progressBar, progressText, () => {
                        // Stop smoke
                        if (smokeInterval) {
                            clearInterval(smokeInterval);
                            smokeInterval = null;
                        }

                        // Remove machine screen
                        setTimeout(() => {
                            machineScreen.classList.remove('shake');
                            setTimeout(() => {
                                machineScreen.remove();
                                smokeContainer.remove();

                                // Start printer animation
                                printerAnimation(designCanvas);
                            }, 300);
                        }, 500);
                    });
                }, 300);
            });
        })();

        /* ============================================
           SCENE 3: VAPORWAVE CASSETTE PLAYER
           ============================================ */
        (function () {
            const container = document.getElementById('player-canvas');
            const visualizerCanvas = document.getElementById('audio-visualizer');
            const playerSection = document.getElementById('player-section');
            let width = container.clientWidth;
            let height = container.clientHeight;

            const scene = new THREE.Scene();
            // Transparent so the canvas visualizer can show through behind the 3D.
            scene.background = null;

            const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
            camera.position.set(8, 5, 8);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(width, height);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Vaporwave Lighting
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const pinkLight = new THREE.PointLight(0xff71ce, 2, 20);
            pinkLight.position.set(-5, 3, 5);
            scene.add(pinkLight);

            const cyanLight = new THREE.PointLight(0x01cdfe, 2, 20);
            cyanLight.position.set(5, 3, -5);
            scene.add(cyanLight);

            const ambLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambLight);

            // Grid Floor
            const gridHelper = new THREE.GridHelper(20, 20, 0xff71ce, 0x01cdfe);
            gridHelper.position.y = -3;
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            const playerGroup = new THREE.Group();
            scene.add(playerGroup);

            // Materials with vaporwave colors
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                roughness: 0.3,
                metalness: 0.5
            });
            const accentMat = new THREE.MeshStandardMaterial({
                color: 0xff71ce,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0xff71ce,
                emissiveIntensity: 0.2
            });
            const windowMat = new THREE.MeshPhysicalMaterial({
                color: 0x111111,
                transmission: 0.8,
                thickness: 1,
                roughness: 0.1
            });
            const innerDarkMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const chassisGroup = new THREE.Group();
            playerGroup.add(chassisGroup);

            // Back Plate
            const back = new THREE.Mesh(new THREE.BoxGeometry(4.5, 5.5, 0.5), bodyMat);
            back.position.z = -0.8;
            back.castShadow = true;
            chassisGroup.add(back);

            // Accent strips
            const stripGeo = new THREE.BoxGeometry(4.6, 0.1, 0.6);
            const topStrip = new THREE.Mesh(stripGeo, accentMat);
            topStrip.position.set(0, 2.5, 0);
            chassisGroup.add(topStrip);

            const bottomStrip = new THREE.Mesh(stripGeo, accentMat);
            bottomStrip.position.set(0, -2.5, 0);
            chassisGroup.add(bottomStrip);

            // Dark inner void
            const voidBox = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2.8, 0.1), innerDarkMat);
            voidBox.position.set(0, 0.25, -0.54);
            chassisGroup.add(voidBox);

            // Bottom Block
            const bottom = new THREE.Mesh(new THREE.BoxGeometry(4.5, 1.5, 1.5), bodyMat);
            bottom.position.set(0, -1.75, 0);
            bottom.castShadow = true;
            chassisGroup.add(bottom);

            // Top Block
            const top = new THREE.Mesh(new THREE.BoxGeometry(4.5, 1, 1.5), bodyMat);
            top.position.set(0, 2, 0);
            top.castShadow = true;
            chassisGroup.add(top);

            // Sides
            const left = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.75, 1.5), bodyMat);
            left.position.set(-1.95, 0.125, 0);
            chassisGroup.add(left);

            const right = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.75, 1.5), bodyMat);
            right.position.set(1.95, 0.125, 0);
            chassisGroup.add(right);

            // Door Frame
            const doorGroup = new THREE.Group();
            doorGroup.position.set(0, 0.25, 0.75);
            playerGroup.add(doorGroup);

            const glassPanel = new THREE.Mesh(new THREE.BoxGeometry(3.0, 2.0, 0.05), windowMat);
            doorGroup.add(glassPanel);

            // Vaporwave Buttons
            const buttons = [];
            const btnColors = [0xff71ce, 0x01cdfe, 0xb967ff, 0x05ffa1];

            function createBtn(x, colorIndex, name) {
                const geo = new THREE.BoxGeometry(0.8, 0.3, 0.4);
                const mat = new THREE.MeshStandardMaterial({
                    color: btnColors[colorIndex],
                    emissive: btnColors[colorIndex],
                    emissiveIntensity: 0.3,
                    roughness: 0.2,
                    metalness: 0.8
                });
                const btn = new THREE.Mesh(geo, mat);
                btn.position.set(x, 2.65, 0);
                btn.castShadow = true;
                btn.userData = { isButton: true, name: name, originalY: 2.65 };
                playerGroup.add(btn);
                buttons.push(btn);
            }

            createBtn(-1.5, 0, 'stop');
            createBtn(-0.5, 1, 'rewind');
            createBtn(0.5, 2, 'play');
            createBtn(1.5, 3, 'ff');

            // Cassette Tape with vaporwave styling
            const tapeGroup = new THREE.Group();
            const tapeBody = new THREE.Mesh(
                new THREE.BoxGeometry(3, 1.8, 0.3),
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 })
            );

            // Gradient label
            const labelCanvas = document.createElement('canvas');
            labelCanvas.width = 256;
            labelCanvas.height = 64;
            const labelCtx = labelCanvas.getContext('2d');
            const labelGradient = labelCtx.createLinearGradient(0, 0, 256, 0);
            labelGradient.addColorStop(0, '#ff71ce');
            labelGradient.addColorStop(0.5, '#b967ff');
            labelGradient.addColorStop(1, '#01cdfe');
            labelCtx.fillStyle = labelGradient;
            labelCtx.fillRect(0, 0, 256, 64);
            labelCtx.fillStyle = 'white';
            labelCtx.font = 'bold 20px sans-serif';
            labelCtx.textAlign = 'center';
            labelCtx.fillText('FLORAL SHOPPE', 128, 40);

            const labelTexture = new THREE.CanvasTexture(labelCanvas);
            const tapeLabel = new THREE.Mesh(
                new THREE.BoxGeometry(2.8, 0.5, 0.32),
                new THREE.MeshBasicMaterial({ map: labelTexture })
            );
            tapeLabel.position.y = 0.5;
            tapeGroup.add(tapeBody);
            tapeGroup.add(tapeLabel);

            // Tape Reels
            const reelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.35, 16);
            const reelMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.3,
                metalness: 0.7
            });
            const leftReel = new THREE.Mesh(reelGeo, reelMat);
            const rightReel = new THREE.Mesh(reelGeo, reelMat);
            leftReel.rotation.x = Math.PI / 2;
            rightReel.rotation.x = Math.PI / 2;
            leftReel.position.set(-0.8, -0.2, 0.1);
            rightReel.position.set(0.8, -0.2, 0.1);

            const tooth = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.4, 0.1),
                new THREE.MeshBasicMaterial({ color: 0x000 })
            );
            leftReel.add(tooth);
            rightReel.add(tooth.clone());
            tapeGroup.add(leftReel);
            tapeGroup.add(rightReel);

            // Keep the tape in playerGroup local space so it always matches rotation
            tapeGroup.position.set(6, 0.25, 0);
            playerGroup.add(tapeGroup);

            // Interaction
            let isDragging = false;
            let pointerId = null;
            let previousPointer = { x: 0, y: 0 };
            let rotVel = { x: 0, y: 0 };
            const dragSensitivity = 0.01;
            const damping = 0.9;
            let tapeInserted = false;
            let isPlaying = false;

            // ==========================
            // AUDIO: FloralShoppeCassette
            // ==========================
            const statusEl = document.getElementById('status-display');
            const audioEl = new Audio();
            audioEl.preload = 'metadata';
            audioEl.loop = false;

            // Keep this list in sync with the files in FloralShoppeCassette/
            const tapePlaylist = [
                { title: 'A1 „Éñ„Éº„Éà', audio: 'FloralShoppeCassette/A1 „Éñ„Éº„Éà.mp3', cover: 'FloralShoppeCassette/A1 „Éñ„Éº„Éà.png' },
                { title: 'A2 „É™„Çµ„Éï„É©„É≥„ÇØ420 Áèæ‰ª£„ÅÆ„Ç≥„É≥„Éî„É•„Éº', audio: 'FloralShoppeCassette/A2 „É™„Çµ„Éï„É©„É≥„ÇØ420 Áèæ‰ª£„ÅÆ„Ç≥„É≥„Éî„É•„Éº.mp3', cover: 'FloralShoppeCassette/A2 „É™„Çµ„Éï„É©„É≥„ÇØ420 Áèæ‰ª£„ÅÆ„Ç≥„É≥„Éî„É•„Éº.png' },
                { title: 'A3 Ëä±„ÅÆÂ∞ÇÈñÄÂ∫ó', audio: 'FloralShoppeCassette/A3 Ëä±„ÅÆÂ∞ÇÈñÄÂ∫ó.mp3', cover: 'FloralShoppeCassette/A3 Ëä±„ÅÆÂ∞ÇÈñÄÂ∫ó.png' },
                { title: 'A4 „É©„Ç§„Éñ„É©„É™', audio: 'FloralShoppeCassette/A4 „É©„Ç§„Éñ„É©„É™.mp3', cover: 'FloralShoppeCassette/A4 „É©„Ç§„Éñ„É©„É™.png' },
                { title: 'A5 Âú∞ÁêÜ', audio: 'FloralShoppeCassette/A5 Âú∞ÁêÜ.mp3', cover: 'FloralShoppeCassette/A5 Âú∞ÁêÜ.png' },
                { title: 'B1 Ecco„Å®ÊÇ™ÂØí„ÉÄ„Ç§„Éì„É≥„Ç∞', audio: 'FloralShoppeCassette/B1 Ecco„Å®ÊÇ™ÂØí„ÉÄ„Ç§„Éì„É≥„Ç∞.mp3', cover: 'FloralShoppeCassette/B1 Ecco„Å®ÊÇ™ÂØí„ÉÄ„Ç§„Éì„É≥„Ç∞.png' },
                { title: 'B2 Êï∞Â≠¶', audio: 'FloralShoppeCassette/B2 Êï∞Â≠¶.mp3', cover: 'FloralShoppeCassette/B2 Êï∞Â≠¶.png' },
                { title: 'B3 ÂæÖÊ©ü', audio: 'FloralShoppeCassette/B3 ÂæÖÊ©ü.mp3', cover: 'FloralShoppeCassette/B3 ÂæÖÊ©ü.png' },
                { title: 'B4 „Éî„Ç≥', audio: 'FloralShoppeCassette/B4 „Éî„Ç≥.mp3', cover: 'FloralShoppeCassette/B4 „Éî„Ç≥.png' },
                { title: 'B5 Â§ñ„ÇÆ„É≥ Aviation', audio: 'FloralShoppeCassette/B5 Â§ñ„ÇÆ„É≥ Aviation.mp3', cover: 'FloralShoppeCassette/B5 Â§ñ„ÇÆ„É≥ Aviation.png' },
                { title: 'B6 „Å¶', audio: 'FloralShoppeCassette/B6 „Å¶.mp3', cover: 'FloralShoppeCassette/B6 „Å¶.png' },
            ];

            let currentTrackIndex = 0;

            let audioCtx = null;
            let analyser = null;
            let analyserData = null;
            let audioSource = null;
            let vizRaf = 0;

            function ensureAudioGraph() {
                if (audioCtx && analyser && audioSource) return;
                const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
                if (!AudioContextCtor) {
                    console.warn('Web Audio API not available; visualizer disabled.');
                    return;
                }
                audioCtx = new AudioContextCtor();
                analyser = audioCtx.createAnalyser();
                // Lower fftSize + smoothing = less CPU + less "glitch"/jitter.
                analyser.fftSize = 1024;
                analyser.smoothingTimeConstant = 0.86;
                analyserData = new Uint8Array(analyser.frequencyBinCount);
                audioSource = audioCtx.createMediaElementSource(audioEl);
                audioSource.connect(analyser);
                analyser.connect(audioCtx.destination);
            }

            function setStatus(text, color) {
                if (!statusEl) return;
                statusEl.innerText = text;
                if (color) statusEl.style.color = color;
            }

            function setTapeLabel(track) {
                // Draw cover + title onto the existing label canvas
                const ctx = labelCtx;
                if (!ctx) return;

                ctx.clearRect(0, 0, labelCanvas.width, labelCanvas.height);

                // gradient base
                const g = ctx.createLinearGradient(0, 0, labelCanvas.width, 0);
                g.addColorStop(0, '#ff71ce');
                g.addColorStop(0.5, '#b967ff');
                g.addColorStop(1, '#01cdfe');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, labelCanvas.width, labelCanvas.height);

                // title
                ctx.fillStyle = 'rgba(255,255,255,0.95)';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(track?.title ? track.title : 'FLORAL SHOPPE', 128, 40);

                labelTexture.needsUpdate = true;

                // Load cover into a THREE texture and swap on the tape body/label if desired
                // (Keeping it minimal here: label text updates instantly even if cover fails.)
            }

            function loadTrack(index) {
                currentTrackIndex = (index + tapePlaylist.length) % tapePlaylist.length;
                const track = tapePlaylist[currentTrackIndex];

                // encodeURI keeps japanese + spaces safe for URL paths
                audioEl.src = encodeURI(track.audio);
                setTapeLabel(track);
                setStatus(`READY Ê∫ñÂÇôÂÆå‰∫Ü\n${track.title}`, '#01cdfe');
            }

            async function playCurrent() {
                if (!tapeInserted) {
                    setStatus('NO TAPE „ÉÜ„Éº„Éó„Å™„Åó', '#ff71ce');
                    return;
                }

                ensureAudioGraph();
                if (audioCtx && audioCtx.state === 'suspended') {
                    try { await audioCtx.resume(); } catch (_) { }
                }

                try {
                    await audioEl.play();
                    isPlaying = true;
                    setStatus(`ÂÜçÁîü‰∏≠ PLAYING >>\n${tapePlaylist[currentTrackIndex].title}`, '#05ffa1');
                    startVisualizer();
                } catch (e) {
                    console.warn('Audio play failed (autoplay restriction or missing file):', e);
                    isPlaying = false;
                    setStatus('PLAY FAILED ÂÜçÁîüÂ§±Êïó', '#ff71ce');
                    stopVisualizer();
                }
            }

            function stopPlayback() {
                audioEl.pause();
                audioEl.currentTime = 0;
                isPlaying = false;
                setStatus(`ÂÅúÊ≠¢ STOPPED\n${tapePlaylist[currentTrackIndex]?.title ?? ''}`, '#ff71ce');
                stopVisualizer();
            }

            function pausePlayback() {
                audioEl.pause();
                isPlaying = false;
                setStatus(`‰∏ÄÊôÇÂÅúÊ≠¢ PAUSED\n${tapePlaylist[currentTrackIndex]?.title ?? ''}`, '#b967ff');
                stopVisualizer();
            }

            function nextTrack() {
                loadTrack(currentTrackIndex + 1);
                if (tapeInserted && isPlaying) playCurrent();
            }

            function prevTrack() {
                loadTrack(currentTrackIndex - 1);
                if (tapeInserted && isPlaying) playCurrent();
            }

            audioEl.addEventListener('ended', () => {
                // Autoplay next track when current ends
                nextTrack();
            });

            // ================
            // VISUALIZER (REWORKED)
            // ================
            const visualizer = (() => {
                if (!visualizerCanvas) return null;
                const ctx = visualizerCanvas.getContext('2d', { alpha: true, desynchronized: true });
                if (!ctx) return null;

                const TARGET_FPS = 60;
                const FRAME_MS = 1000 / TARGET_FPS;
                const SAMPLES = 256;
                const AUDIO_WAVE_GAIN = 10;

                let running = false;
                let raf = 0;
                let lastFrameMs = 0;

                let dpr = 1;
                let cssW = 1;
                let cssH = 1;

                let timeFloat = null;
                let timeByte = null;
                let freqByte = null;
                const down = new Float32Array(SAMPLES);
                const smooth = new Float32Array(SAMPLES);

                // Pre-rendered background (radial + scanlines) rebuilt only on resize
                const bg = document.createElement('canvas');
                const bgCtx = bg.getContext('2d');

                function rebuildBackground() {
                    if (!bgCtx) return;
                    bg.width = Math.max(1, cssW);
                    bg.height = Math.max(2, cssH);

                    bgCtx.clearRect(0, 0, bg.width, bg.height);

                    // Soft radial neon "sun" behind everything
                    const r = Math.max(bg.width, bg.height) * 0.55;
                    const cx = bg.width * 0.5;
                    const cy = bg.height * 0.52;
                    const g = bgCtx.createRadialGradient(cx, cy, 0, cx, cy, r);
                    g.addColorStop(0, 'rgba(1, 205, 254, 0.14)');
                    g.addColorStop(0.35, 'rgba(185, 103, 255, 0.08)');
                    g.addColorStop(0.7, 'rgba(255, 113, 206, 0.05)');
                    g.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    bgCtx.fillStyle = g;
                    bgCtx.fillRect(0, 0, bg.width, bg.height);

                    // Thin scanlines (cheap, static)
                    bgCtx.globalCompositeOperation = 'screen';
                    bgCtx.fillStyle = 'rgba(255,255,255,0.025)';
                    for (let y = 0; y < bg.height; y += 4) bgCtx.fillRect(0, y, bg.width, 1);
                    bgCtx.globalCompositeOperation = 'source-over';
                }

                function resize() {
                    const rect = container ? container.getBoundingClientRect() : visualizerCanvas.getBoundingClientRect();
                    cssW = Math.max(1, Math.floor(rect.width));
                    cssH = Math.max(2, Math.floor(rect.height));
                    dpr = Math.min(window.devicePixelRatio || 1, 2);

                    visualizerCanvas.style.width = cssW + 'px';
                    visualizerCanvas.style.height = cssH + 'px';
                    visualizerCanvas.width = Math.floor(cssW * dpr);
                    visualizerCanvas.height = Math.floor(cssH * dpr);
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                    rebuildBackground();
                }

                function sampleTimeDomain(tSeconds) {
                    const audioActive = !!(analyser && isPlaying && !audioEl.paused);

                    if (audioActive) {
                        // Prefer float data for smoother visuals.
                        if (typeof analyser.getFloatTimeDomainData === 'function') {
                            if (!timeFloat || timeFloat.length !== analyser.fftSize) timeFloat = new Float32Array(analyser.fftSize);
                            analyser.getFloatTimeDomainData(timeFloat);

                            const step = timeFloat.length / SAMPLES;
                            for (let i = 0; i < SAMPLES; i++) {
                                // RMS-ish sampling over a small window to reduce jitter
                                const start = Math.floor(i * step);
                                const end = Math.min(timeFloat.length, Math.floor((i + 1) * step));
                                let acc = 0;
                                let count = 0;
                                for (let j = start; j < end; j++) {
                                    const v = timeFloat[j];
                                    acc += v;
                                    count++;
                                }
                                down[i] = count ? (acc / count) : 0;
                            }
                        } else {
                            if (!timeByte || timeByte.length !== analyser.fftSize) timeByte = new Uint8Array(analyser.fftSize);
                            analyser.getByteTimeDomainData(timeByte);
                            const step = timeByte.length / SAMPLES;
                            for (let i = 0; i < SAMPLES; i++) {
                                down[i] = ((timeByte[Math.floor(i * step)] - 128) / 128);
                            }
                        }
                    } else {
                        // Idle: lissajous-style ribbon (stable, smooth)
                        for (let i = 0; i < SAMPLES; i++) {
                            const p = i / (SAMPLES - 1);
                            const a = Math.sin(p * Math.PI * 6 + tSeconds * 1.6) * 0.55;
                            const b = Math.sin(p * Math.PI * 2 - tSeconds * 0.9) * 0.25;
                            const c = Math.sin(p * Math.PI * 12 + tSeconds * 0.35) * 0.12;
                            down[i] = (a + b + c) * 0.85;
                        }
                    }

                    // Boost audio amplitude (keep idle unchanged)
                    if (audioActive) {
                        for (let i = 0; i < SAMPLES; i++) {
                            const v = down[i] * AUDIO_WAVE_GAIN;
                            down[i] = Math.max(-1, Math.min(1, v));
                        }
                    }

                    // Critically damped smoothing for stability
                    const follow = audioActive ? 0.22 : 0.12;
                    for (let i = 0; i < SAMPLES; i++) {
                        smooth[i] = smooth[i] + (down[i] - smooth[i]) * follow;
                    }

                    // Frequency data for a subtle bottom haze (optional)
                    if (audioActive && analyserData) {
                        if (!freqByte || freqByte.length !== analyserData.length) freqByte = analyserData;
                        analyser.getByteFrequencyData(freqByte);
                        visualizerCanvas.classList.add('is-active');
                    } else {
                        visualizerCanvas.classList.remove('is-active');
                    }
                }

                function drawWave(tSeconds) {
                    // Background
                    ctx.clearRect(0, 0, cssW, cssH);
                    ctx.drawImage(bg, 0, 0, cssW, cssH);

                    // Wave ribbon
                    const mid = cssH * 0.56;
                    const amp = cssH * 0.34;

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';

                    // Glow passes (big -> small)
                    const passes = [
                        { w: 14, a: 0.08, c: 'rgba(255, 113, 206, 1)', blur: 24 },
                        { w: 7, a: 0.16, c: 'rgba(185, 103, 255, 1)', blur: 16 },
                        { w: 3, a: 0.9, c: 'rgba(1, 205, 254, 1)', blur: 8 },
                    ];

                    for (const p of passes) {
                        ctx.beginPath();
                        ctx.lineWidth = p.w;
                        ctx.strokeStyle = p.c;
                        ctx.globalAlpha = p.a;
                        ctx.shadowColor = p.c;
                        ctx.shadowBlur = p.blur;

                        // Quadratic smoothing
                        let x0 = 0;
                        let y0 = mid + smooth[0] * amp;
                        ctx.moveTo(x0, y0);

                        for (let i = 1; i < SAMPLES; i++) {
                            const x = (i / (SAMPLES - 1)) * cssW;
                            const y = mid + smooth[i] * amp;
                            const cx = (x0 + x) * 0.5;
                            const cy = (y0 + y) * 0.5;
                            ctx.quadraticCurveTo(x0, y0, cx, cy);
                            x0 = x;
                            y0 = y;
                        }
                        ctx.lineTo(cssW, y0);
                        ctx.stroke();
                    }

                    ctx.restore();

                }

                function tick(nowMs) {
                    if (!running) return;
                    raf = requestAnimationFrame(tick);

                    if (nowMs - lastFrameMs < FRAME_MS) return;
                    lastFrameMs = nowMs;

                    // Keep canvas size stable; only resize when needed.
                    const rect = container ? container.getBoundingClientRect() : visualizerCanvas.getBoundingClientRect();
                    const nextW = Math.max(1, Math.floor(rect.width));
                    const nextH = Math.max(1, Math.floor(rect.height));
                    const nextDpr = Math.min(window.devicePixelRatio || 1, 2);
                    if (nextW !== cssW || nextH !== cssH || nextDpr !== dpr) resize();

                    const t = nowMs * 0.001;
                    sampleTimeDomain(t);
                    drawWave(t);
                }

                function start() {
                    if (running) return;
                    running = true;
                    resize();
                    lastFrameMs = performance.now();
                    raf = requestAnimationFrame(tick);
                }

                function stop(clear = false) {
                    running = false;
                    if (raf) cancelAnimationFrame(raf);
                    raf = 0;
                    if (clear) ctx.clearRect(0, 0, cssW, cssH);
                }

                return { start, stop, resize };
            })();

            function resizeVisualizerCanvas() {
                visualizer?.resize();
            }

            function startVisualizer() {
                visualizer?.start();
            }

            function stopVisualizer(offscreen) {
                // If offscreen, fully stop + clear. Otherwise keep it visible (idle mode).
                if (offscreen) visualizer?.stop(true);
            }

            // Pause 3D render + visualizer when off-screen / tab hidden
            let playerRaf = 0;
            let playerIsRunning = false;
            let playerInView = true;

            function playerLoop() {
                if (!playerIsRunning) return;
                playerRaf = requestAnimationFrame(playerLoop);

                const t = Date.now() * 0.001;

                if (!isDragging) {
                    // Inertia
                    playerGroup.rotation.x += rotVel.x;
                    playerGroup.rotation.y += rotVel.y;
                    playerGroup.rotation.x = Math.max(-0.9, Math.min(0.6, playerGroup.rotation.x));
                    rotVel.x *= damping;
                    rotVel.y *= damping;
                }

                renderer.render(scene, camera);

                if (tapeInserted && isPlaying) {
                    leftReel.rotation.y -= 0.1;
                    rightReel.rotation.y -= 0.1;
                }

                // Animate lights
                pinkLight.position.x = Math.sin(t * 0.5) * 5;
                cyanLight.position.z = Math.cos(t * 0.5) * 5;

                // Subtle grid animation
                gridHelper.rotation.y += 0.001;
            }

            function playerStart() {
                if (playerIsRunning) return;
                playerIsRunning = true;
                playerRaf = requestAnimationFrame(playerLoop);
            }

            function playerStop() {
                playerIsRunning = false;
                if (playerRaf) cancelAnimationFrame(playerRaf);
                playerRaf = 0;
            }

            function playerUpdateRunning() {
                const shouldRun = playerInView && !document.hidden;
                if (shouldRun) {
                    playerStart();
                    // Always show the oscillator as a background when the cassette area is visible.
                    startVisualizer();
                } else {
                    playerStop();
                    // Keep audio playing, but stop drawing the visualizer when off-screen.
                    stopVisualizer(true);
                }
            }

            if (playerSection) {
                const playerObserver = new IntersectionObserver(
                    (entries) => {
                        playerInView = entries.some(e => e.isIntersecting);
                        playerUpdateRunning();
                    },
                    { threshold: 0.05 }
                );
                playerObserver.observe(playerSection);
            }
            document.addEventListener('visibilitychange', playerUpdateRunning);

            container.style.touchAction = 'none';

            container.addEventListener('pointerdown', (e) => {
                isDragging = true;
                pointerId = e.pointerId;
                container.setPointerCapture(pointerId);
                previousPointer = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('pointerup', () => {
                isDragging = false;
                pointerId = null;
            });

            container.addEventListener('pointercancel', () => {
                isDragging = false;
                pointerId = null;
            });

            container.addEventListener('pointermove', (e) => {
                if (!isDragging || e.pointerId !== pointerId) return;
                const deltaX = e.clientX - previousPointer.x;
                const deltaY = e.clientY - previousPointer.y;

                const vy = deltaX * dragSensitivity;
                const vx = deltaY * dragSensitivity;

                playerGroup.rotation.y += vy;
                playerGroup.rotation.x += vx;

                // Clamp X rotation a bit so it doesn't flip
                playerGroup.rotation.x = Math.max(-0.9, Math.min(0.6, playerGroup.rotation.x));

                rotVel.x = vx;
                rotVel.y = vy;
                previousPointer = { x: e.clientX, y: e.clientY };
            });

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            container.addEventListener('click', (event) => {
                const rect = container.getBoundingClientRect();
                const currentWidth = rect.width;
                const currentHeight = rect.height;
                mouse.x = ((event.clientX - rect.left) / currentWidth) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / currentHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(playerGroup.children);
                for (let i = 0; i < intersects.length; i++) {
                    if (intersects[i].object.userData.isButton) pressButton(intersects[i].object);
                }
            });

            function pressButton(btn) {
                const targetY = btn.userData.originalY - 0.2;
                buttons.forEach(b => b.position.y = b.userData.originalY);
                btn.position.y = targetY;

                if (!tapeInserted) {
                    setStatus('NO TAPE „ÉÜ„Éº„Éó„Å™„Åó', '#ff71ce');
                    return;
                }

                if (btn.userData.name === 'play') {
                    // Toggle play/pause when already playing
                    if (isPlaying && !audioEl.paused) {
                        pausePlayback();
                    } else {
                        playCurrent();
                    }
                } else if (btn.userData.name === 'stop') {
                    stopPlayback();
                } else if (btn.userData.name === 'rewind') {
                    setStatus('Â∑ª„ÅçÊàª„Åó <<', '#01cdfe');
                    prevTrack();
                } else {
                    setStatus('Êó©ÈÄÅ„Çä >>', '#b967ff');
                    nextTrack();
                }
            }

            document.getElementById('insert-tape-btn').addEventListener('click', () => {
                if (tapeInserted) return;

                let pos = tapeGroup.position.x;
                const insertAnim = setInterval(() => {
                    pos -= 0.15;
                    tapeGroup.position.x = pos;

                    if (pos <= 0) {
                        clearInterval(insertAnim);
                        tapeGroup.position.set(0, 0.25, 0);
                        tapeInserted = true;
                        loadTrack(0);
                        setStatus('„É≠„Éº„ÉâÂÆå‰∫Ü LOADED', '#01cdfe');
                    }
                }, 16);
            });

            // Start/stop loop based on visibility
            playerUpdateRunning();

            window.addEventListener('resize', () => {
                width = container.clientWidth;
                height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
                resizeVisualizerCanvas();
            });
        })();
    </script>
</body>

</html>